File title: None                 
Number of pages: 118


1/118  
 




2/118  
FOREWORD TO THE THIRD EDITION .................................................................................................................................. .4 
FOREWORD TO THE FIRST EDITION ................................................................................................................................... .5 
PREFACE .......................................................................................................................................................................... .5 
Why Bother with the UML? ....................................................................................................................................... .6 
Structure of the Book ................................................................................................................................................. .7 
Changes for the Third Edition ................................................................................................................................... .7 
Acknowledgments ..................................................................................................................................................... .7 
DIAGRA MS...................................................................................................................................................................... . 10 
CHAPTER 1. INTRODUCTION ........................................................................................................................................... . 14 
What Is the UML? .................................................................................................................................................... .14 
Where to Find Out More ......................................................................................................................................... .14 
Ways of Using the UML .......................................................................................................................................... .15 
How We Got to the UML ......................................................................................................................................... .18 
Notations and Meta-Models .................................................................................................................................... .20 
UML Diagrams ......................................................................................................................................................... .21 
What Is Legal UML? ................................................................................................................................................ .23 
The Meaning of UML ............................................................................................................................................... .24 
UML Is Not Enough ................................................................................................................................................. .24 
Where to Star t with the UML ................................................................................................................................... .25 
CHAPTER 2. DEVELOPMEN T PROCESS ........................................................................................................................... . 26 
Iterative and Waterfall Processes ........................................................................................................................... .26 
Predictive and Adaptive Planning ........................................................................................................................... .28 
Agile Processes ....................................................................................................................................................... .29 
Rational Unified Process ......................................................................................................................................... .30 
Fitting a Process to a Project .................................................................................................................................. .30 
Fitting the UML into a Process ............................................................................................................................... .32 
Choosing a Development Process ......................................................................................................................... .35 
Where to Find Out More ......................................................................................................................................... .35 
CHAPTER 3. CLASS DIAGRA MS: THE ESSENTIALS .......................................................................................................... . 35 
Properties ................................................................................................................................................................. .36 
When to Use Class Diagrams ................................................................................................................................ .38 
Where to Find Out More ......................................................................................................................................... .38 
Multiplicity ................................................................................................................................................................. .38 
Programming Interpretation of Properties ............................................................................................................. .39 
Bidirectional Associations ....................................................................................................................................... .41 
Operations ................................................................................................................................................................ .42 
Generalizati on.......................................................................................................................................................... .43 
Notes and Comments ............................................................................................................................................. .44 
Dependency ............................................................................................................................................................. .44 
Constraint Rules ...................................................................................................................................................... .46 
CHAPTER 4. SEQUENCE DIAGRA MS................................................................................................................................ . 47 
Creating and Deleting Participants ......................................................................................................................... .50 
Loops, Conditionals, and the Like .......................................................................................................................... .51 
Synchronous and Asynchronous Calls .................................................................................................................. .54 
When to Use Sequence Diagrams ......................................................................................................................... .54 
CHAPTER 5. CLASS DIAGRA MS: ADVANCE D CONCEP TS................................................................................................. . 56 
Keywords ................................................................................................................................................................. .56 
Classification and Generalization ........................................................................................................................... .57 
Multiple and Dynamic Classification ....................................................................................................................... .57 
Association Class .................................................................................................................................................... .58 
Template (Parameterized) Class ............................................................................................................................ .61 
Enumerations ........................................................................................................................................................... .62 
Active Class ............................................................................................................................................................. .63 
Visibility.................................................................................................................................................................... .63 
Messages ................................................................................................................................................................. .64 
Responsibilities ........................................................................................................................................................ .64 
Static Operations and Attributes ............................................................................................................................. .65 
Aggregation and Composition ................................................................................................................................ .65 
Derived Properties ................................................................................................................................................... .66 
Interfaces and Abstract Classes ............................................................................................................................. .67 
Read-Only and Frozen ............................................................................................................................................ .70 
Reference Objects and Value Objects ................................................................................................................... .70 
Qualified Associations ............................................................................................................................................. .71 
CHAPTER 6. OBJEC T DIAGRA MS..................................................................................................................................... . 72 



3/118 When to Use Object Diagrams ............................................................................................................................... .72 
CHAPTER 7. PACKAGE DIAGRA MS.................................................................................................................................. . 73 
Packages and Dependencies ................................................................................................................................. .74 
Package Aspects ..................................................................................................................................................... .76 
Implementing Packages .......................................................................................................................................... .76 
When to Use Package Diagrams ........................................................................................................................... .77 
Where to Find Out More ......................................................................................................................................... .78 
CHAPTER 8. DEPLOYMEN T DIAGRA MS............................................................................................................................ . 78 
When to Use Deployment Diagrams ...................................................................................................................... .79 
CHAPTER 9. USE CASES ................................................................................................................................................ . 79 
Content of a Use Case ............................................................................................................................................ .80 
Use Case Diagrams ................................................................................................................................................ .81 
Levels of Use Cases ............................................................................................................................................... .82 
Use Cases and Features (or Stories) .................................................................................................................... .82 
When to Use Use Cases ......................................................................................................................................... .83 
Where to Find Out More ......................................................................................................................................... .83 
CHAPTER 10. STATE MACHINE DIAGRA MS..................................................................................................................... . 83 
Internal Activities ..................................................................................................................................................... .85 
Activity States .......................................................................................................................................................... .85 
Superstates .............................................................................................................................................................. .86 
Concurrent States .................................................................................................................................................... .86 
Implementing State Diagrams ................................................................................................................................ .87 
When to Use State Diagrams ................................................................................................................................. .89 
Where to Find Out More ......................................................................................................................................... .89 
CHAPTER 11. ACTIVITY DIAGRA MS................................................................................................................................. . 89 
Decomposing an Action .......................................................................................................................................... .91 
And There's More .................................................................................................................................................... .93 
When to Use Activity Diagrams .............................................................................................................................. .93 
Where to Find Out More ......................................................................................................................................... .93 
Partitions.................................................................................................................................................................. .93 
Signals...................................................................................................................................................................... .94 
Tokens...................................................................................................................................................................... .95 
Flows and Edges ..................................................................................................................................................... .96 
Pins and Transformations ....................................................................................................................................... .96 
Expansion Regions ................................................................................................................................................. .97 
Flow Final ................................................................................................................................................................. .98 
Join Specifications ................................................................................................................................................... .99 
CHAPTER 12. COMMUNICATION DIAGRA MS.................................................................................................................. . 100 
When to Use Communication Diagrams .............................................................................................................. .101 
CHAPTER 13. COMPOSITE STRUCTURES ...................................................................................................................... . 101 
When to Use Composite Structures ..................................................................................................................... .103 
CHAPTER 14. COMPONEN T DIAGRA MS......................................................................................................................... . 103 
When to Use Component Diagrams .................................................................................................................... .105 
CHAPTER 15. COLLABORATIONS .................................................................................................................................. . 105 
When to Use Collaborations ................................................................................................................................. .107 
CHAPTER 16. INTERACTION OVERVIE W DIAGRA MS....................................................................................................... . 107 
When to Use Interaction Overview Diagrams ..................................................................................................... .108 
CHAPTER 17. TIMING DIAGRA MS.................................................................................................................................. . 109 
When to Use Timing Diagrams ............................................................................................................................. .110 
APPENDI X CHANGES BETWEEN UML  VERSIONS ........................................................................................................... . 110 
Revisions to the UML ............................................................................................................................................ .110 
Changes in UML Distilled ...................................................................................................................................... .111 
Changes from UML 1.0 to 1.1 .............................................................................................................................. .112 
Changes from UML 1.2 (and 1.1) to 1.3 (and 1.5) .............................................................................................. .113 
Changes from UML 1.3 to 1.4 .............................................................................................................................. .114 
Changes from UML 1.4. to 1.5 ............................................................................................................................. .114 
From UML 1.x to UML 2.0 ..................................................................................................................................... .114 
BIBLIOGRA PHY.............................................................................................................................................................. . 116 
 
 
 
 



4/118 Foreword to the Third Edition 
Since ancient times, the m ost talented archite cts and the most gifted designers have known the law 
of parsim ony. Whether it is stated as a paradox ("less is more"), or a koan ("Zen mind is beginner's 
mind"), its wisdom is timeless: Reduce every thing to its essence s o that form harm onizes wit h 
function. From  the pyramids t o the Sydney Opera H ouse, from von Neumann ar chitectures to UNIX 
and Smalltalk, the best arch itects and designe rs have strived to fo llow this universal and eterna l 
principle. 
Recognizing the value of shaving with Occam's Razor, when I architect and read I seek pr ojects and 
books that adhere to the law of parsimony. Consequen tly, I applaud the b ook you are reading  now. 
You may find my last remark surprising at first. I am frequently ass ociated with the v oluminou s and 
dense specifica tions that define the Unified Modeling Language (UML). These specifica tions a llow tool 
vendors t o implement the UML and methodologists to apply it. For seven years, I have chaired  large 
international standardizati on teams to specify  UML 1.1 and UML 2.0, as well as several minor 
revisions in between. During this  time, the UML has matured in expressiveness and precision,  but it 
has also added gratu itous complexity as a result of the standardiza tion process. Regrettably, 
standardization processes are be tter known for design-by-committee compromises  than 
parsim onious elegance. 
What can a UML expert familiar with the arcane minu tiae of the specificati on learn fr om Martin's 
distillation of UML 2.0? Q uite a bit, as can you. To start with, Martin adroitly reduces a large an d 
complex language  into a pragmatic subset tha t he has proven effective  in his practice. He ha s 
resisted the easy r oute of tacking on additional pages to the last editi on of his b ook. As the language 
has grown, Martin has kept true to his goal of seeking the "fraction of UML  that is m ost useful" and 
telling y ou just that. The fra ction he refers to is the mythical 20 percent of UML  that helps y ou do 80 
percent of your work. Capturing and taming this elusive beast is no mean accomplishment ! 
It is even more impressive that Martin a chieves this goal while writing in a wonderfully engagin g 
conversational style. By sharing his op inions and anecdotes with us, he makes this b ook fun t o read 
and reminds us that arc hitecting and designin g systems sh ould be b oth creative and productive. I f 
we pursue the parsimony koan to its full intent, we should find UML modeling pr ojects to be as 
enjoyable as we f ound finger-pain ting and drawing classes  in grammar sch ool. UML should be a 
lightning rod for our creativity as well as a laser for precisely specifying system blueprints s o that 
third parties can bid and build th ose systems. The latter is the acid test for any bona fide blueprin t 
language. 
So, wh ile this may be a small b ook, it is not a trivial one. Y ou can learn as  much from Martin's 
approach to modeling as you can learn fr om his explanati ons of UML 2.0. 
I have en joyed working with Ma rtin to improve  the selecti on and correctness of the UML 2. 0 
language features explained in this revision. We need t o keep in mind that all living languages, both 
natural and synthetic, must ev olve or perish. Martin's choices of new features, along with you r 
preferences and th ose of other practitioners, a re a crucial part of the UML revision process. The y 
keep the language vital and help  it evolve via natural selecti on in the marketplace. 
Much challenging work remains before model-driven development becomes mainstream, but I am 
encouraged by b ooks like this that explain UML modeling basics clearly and apply  them 
pragmatically. I hope y ou will learn fr om it as I have and wi ll use your new  insights t o improv e your 
own s oftware modeling practices. 
Cris Kobryn 
Chair, U2 Partners' UML 2.0 Submission Team 
Chief Technologist, Telelogic 
 



5/118 Foreword to the First Edition 
When we began to craft the Unified Modeling Language, we hoped that we c ould produce a standard 
means of expressing design that w ould not only reflect the best pra ctices of industry, but woul d also 
help demystify  the process of s oftware system modeling. We be lieved that  the availability of a 
standard modeling language w ould encourage more developers t o model their software system s 
before building them. The rapid and widespread adop tion of the UML dem onstrates that the benefits 
of mode ling are indeed well known to the developer c ommunity. 
The crea tion of the UML was itself an iterative and incremental process very similar t o the modeling 
of a large s oftware system. The end re sult is a standard built on, and reflec tive of, the many i deas 
and contributi ons made by numerous individuals and companies from the object c ommunity. W e 
began the UML effort, but many others helped bring it to a successful con clusion; we are grate ful for 
their c ontribution. 
Creating and agreeing on a standard modeling  language is a significant challenge by  itself. Educating 
the development community, and presenting the UML in a manner  that is b oth accessible and in the 
context of the s oftware development process, is also a significant challenge. In this deceptively shor t 
book, updated to reflect  the most recent changes t o the UML, Martin Fowler has more than me t this 
challenge. 
In a clear and friendly style, Martin not only introduces the key aspects of UML, but also clearly 
demonstrates the role UML plays  in the development process.  Along the way, we are treated t o 
abundant nuggets of modeling insight and wisdom drawn from Martin's 12-plus years of design and 
modeling experience. 
The result is a b ook that has  introduced many thousands of developers to UML, whetting their 
appetite t o further explore the many benef its of modeling with this now standard modeling 
language. 
We rec ommend the b ook to any modeler or developer interested in ge tting a first l ook at UML and i n 
gaining a perspe ctive on the key role it plays i n the development pr ocess. 
Grady B ooch 
Ivar Jacobson 
James Rumbaugh 
 
Preface 
I've been lucky in a lot of ways in my life; one of my great str okes of fortune was being in the righ t 
place with  the right knowledge to write the first editi on of this b ook in 1997. Back then, the chao tic 
world of object-oriented (OO) modeling was ju st begin ning to unify under the  Unified Modelin g 
Language (UML). Since then, the UML has become the standard for the graphical modeling of 
software, n ot just for objects. My for tune is that this b ook has been the most popular b ook on the 
UML, se lling more than a quarter of a milli on copies. 
Well, that's very nice for me, but sh ould you buy this b ook? 
I like t o stress that this is a brief b ook. It's not  intended to give you the details on every facet of the 
UML, which has grown and grown over the years. My intenti on is to find that fra ction of the UML tha t 
is most useful and tell you just that. Although a bigger b ook gives you more deta il, it als o takes 
longer t o read. And your time is the biggest investment you'll make  in a book. By keeping this book 
small, I've spent  the time selec ting the best bi ts to save you from ha ving to do that selec tion 
yourself. (Sadly, being smaller doesn't mean propor tionately cheaper; there is a certain fixed cost to 
producing a quality technical b ook.) 



6/118 One reas on to have this b ook is to begin to learn ab out the UML. Because this is a short b ook, it will 
quickly get you up to speed on the essen tials of the UML.  With that  under your belt, you can go int o 
more detail on the UML with  the bigger b ooks, such as the User Guide  [Booch, UML user] or th e 
Reference Manual  [Rumbaugh, UML Reference] . 
This b ook can also act as a handy reference t o the most c ommon parts of the UML. A lthough the 
book doesn't cover everyt hing, it's a lot lighter to carry ar ound than most other UML b ooks. 
It's also an opinionated b ook. I've been working with objects for a long time now, and I hav e 
definite ideas ab out what works and what doe sn't. Any b ook reflects the opini ons of the author, and 
I don't try t o hide mine. So if you're l ooking fo r something  that has a flavor of objectivity, you migh t 
want t o try something else. 
Although many people have told me  that this book is a g ood introduction to objects, I didn't write i t 
with that in mind. If you are after an introduc tion to OO design, I suggest Craig Larman's b ook 
[Larman]. 
Many people who are interested  in the UML are using t ools. This b ook concentrates on the standard 
and on conventional usage of the UML and doesn't get int o the deta ils of what various t ools support. 
Although the UML did resolve the tower of Babel of pre-UML notati ons, many annoying differences 
remain between what t ools show and a llow when drawing UML diagrams. 
I don't say much  in this book about Model Driven Archite cture (MDA). Although many peopl e 
consider  the two to be the same thing, many developers use  the UML without being interested  in 
MDA. If y ou want to learn more ab out MDA, I would start with  this book to get an overview of  the 
UML first and then move on to a b ook that's more specific ab out MDA. 
Although the main point of this book is the UML, I've also added bits of other material ab out 
techniques, such as CRC cards,  that are valuable for OO design. The UML is just a part of what you 
need to succeed with objects, and I t hink that it's important t o introduce y ou to some other 
techniques. 
In a brief b ook like this, it's impossible to g o into detail about how the UML relates to source code, 
particularly as there is no standard way of ma king that corresp ondence. However, I do point ou t 
comm on coding te chniques for implementing pieces of the UML. My code examples are in Java and 
C#, as I've found that these languages are usua lly the m ost widely underst ood. Don't assume  that I 
prefer those languages; I've done t oo much Smalltalk for that ! 
Why Bother with the UML? 
Graphical design notations have been with us for a w hile. For me, their primary value is i n 
communica tion and understanding. A g ood diagram can often help c ommunicate ideas about a 
design, particularly when you want to avoid a lot of details. Diagrams can also help y ou understand 
either a s oftware system or a business pr ocess. As part of a team trying to figure out something, 
diagrams b oth help understanding and c ommunicate that understanding  through out a team. 
Although they aren't, at least yet, a replacement for textual programming languages, they are a 
helpful assistant. 
Many people believe that in  the future, graphical te chniques will play a dominant role  in software 
development. I'm more skeptical of that, but  it's certainly useful to have an appreciation of what 
these nota tions can and can't do. 
Of these graphical notati ons, the UML's importance comes from its wide use and standardization 
within the OO development community. The UML has become not only the dominant graphica l 
notati on within the OO world but also a popula r technique in non-OO circles. 
 



7/118 Structure of the Book 
Chapter 1  gives an introduc tion to the UML: what it is, the different meanings it has to differen t 
people, and where  it came from. 
Chapter 2  talks ab out software process. Although this is strictly  independent of the UML, I think tha t 
it's essen tial to understand process in order to see the c ontext of somet hing like the UML. I n 
particular, it's important to understand  the role  of itera tive development, which has been the 
underlying approach to pr ocess for most of th e OO community. 
I've organized the rest of the b ook around the diagram types w ithin the UML. Chapters  3 and 4 
discuss the tw o most useful parts of  the UML: class diagrams (core) and sequence diagrams. Even 
though this b ook is slim, I believe that you can get the m ost value out of the UML by using the 
techniques  that I talk about in these chapters. The UML is a large and growing beast, but you don' t 
need all of it. 
Chapter 5  goes  into detail on the less essen tial but s till useful parts of class diagrams. Chapters 6  
throug h 8 describe three useful diagrams that shed fu rther light on th e structure  of a system: objec t 
diagrams, package diagrams, and deployment diagrams. 
Chapters  9 through 11 show three further usefu l behavior al techniques: use cases, state diagrams 
(although officially known as state mac hine diagrams, they are generally called state diagrams), and 
activity diagrams. Chapters 12 throug h 17 are very brief and cover diagrams that are generally less 
important, s o for these, I've only pr ovided a q uick example and explanation. 
The inside covers summarize the m ost useful parts of the notation. I've often heard people say tha t 
these covers are  the most valuable part of the b ook. You'll probably find it handy t o refer to them as 
you're reading some of the other parts of the book. 
Changes for the Third Edition 
If you have ear lier editi ons of this book, you're probably wondering what is different and, mor e 
important, whether y ou should buy  the new ed ition. 
The primary trigger for the  third edition was the appearance of UML 2. UML 2 has added a l ot of new 
stuff, including several new diagram types. Even familiar diagrams have a lot of new notation, such 
as interac tion frames in sequence diagrams. If  you want to be aware of what's happened but don' t 
want to wade through  the specificati on (I certainly don't recommend that!),  this book should give 
you a g ood overview. 
I've als o taken this opportunity to completely rewr ite most of the b ook, bringing the text and 
examples up to date. I've incorporated much that I've learned in teac hing and using the UML over 
the past five years. So although the spirit of this ultrathin UML b ook is intact, m ost of the words are 
new. 
Over the years, I've worked hard to keep this b ook as current as is possible. As the UML has gone 
through its changes, I've d one my best t o keep pace. This b ook is based on the UML 2 drafts that 
were accepted by the relevant committee in J une 2003. It's  unlikely that further changes will occur 
between that vote and more formal votes, so I feel  that UML 2 is now stable enough for my re vision 
to go into print. I'll post information any further updates on my Web site 
(http://martinfowler.com ). 
 
 
Acknowledgments 



8/118 Over many years, many people have been part  of the success of this b ook. My first thanks go Carte r 
Shanklin and Kendall Sco tt. Carter was the editor at Addison-Wesley who suggested  this book to 
me. Kendall Sc ott helped me put together the first two editions, working over the text and graphics. 
Between  them, they pulled off the impossible in get ting the first edi tion out in an impossibly shor t 
time, while keeping up the  high quality that people expect from Addison-Wesley. They also kep t 
pushing out changes during  the early days of  the UML when not hing seemed stable. 
Jim Odell has been my mentor and guide for much of the early part of my career. He's also bee n 
deeply involved with the te chnical and personal  issues of making opinionated methodologists set tle 
their differences and agree to a common standard. His c ontribution to this b ook is both prof ound 
and difficult to measure, and I bet it's the sam e for the UML t oo. 
The UML is a creature of standards, but I'm allergic to standards bodies. S o to know what's g oing 
on, I need a network of spies who can keep me up to date on all the machina tions of th e 
committees. Without  these spies, including Conrad Bock, Steve C ook, Cris Kobryn, Jim Ode ll, Guus 
Ramackers, and Jim Rumbaugh, I w ould be sunk. They've all given me useful  tips and answe red 
stupid questions. 
Grady B ooch, Ivar Jacobson, and Jim Rumbaugh are known as  the Three Amigos. Despite the playfu l 
jibes I've given  them over  the years,  they have given me much support and encouragement w ith 
this b ook. Never forget that my jabs usually s prout from fond appreciation. 
Reviewers are the key to a b ook's qua lity, and I learned from Carter that you can never have to o 
many reviewers. The reviewers of  the previou s editions of this book were Simmi K ochhar Bhargava, 
Grady B ooch, Eric Evans, T om Hadfield, Ivar Ja cobson, Ronald E. Jeffries, J oshua Kerievsky, Helen 
Klein, Jim Ode ll, Jim Rumbaugh, and Vivek Salgar. 
The third editi on also had a fine group of reviewers: 
Conrad B ock Craig Larman 
Andy Carmichael Steve Me llor 
Alistair Cockburn Jim Odel l 
Steve C ook Alan O'Ca llaghan 
Luke H ohmann Guus Ramackers 
Pavel Hruby Jim Rumbaugh 
Jon Kern Tim Seltzer 
Cris Kobryn   
All these reviewers spent time reading the manuscript, and every one of them f ound at least one 
embarrassing howler. My sincere thanks to all of them.  Any howlers that remain are entirely my 
responsibility. I will post an errata sheet t o the books sec tion of martinfowler.com  when I find 
them. 
The core team that designed and wrote  the UML specifica tion are Don Baisley, Morgan B jörkander, 
Conrad B ock, Steve C ook, Philippe Desfray, Nathan Dykman,  Anders Ek, David Frankel, Eran Gery, 
Øystein Haugen, Sridhar Iyengar, Cris Kobryn, Birger M øller-Pedersen, James Odell,  Gunnar 
Övergaard, Karin Palmkvist, Guus Ramackers, Jim Rumbaugh, Bran Selic, Thomas Weigert, and 
Larry Williams. W ithout them, I w ould have n othing to write ab out. 
Pavel Hruby developed some excellent Visi o templates that I use a lot for UML diagrams; you can 
get them a t http://phruby.com . 
Many people have c ontacted me on the Net and in person w ith suggestions and questi ons and t o 
point out errors. I haven't been able to keep track of you all, but my thanks are no less sincere . 



9/118 The people at my favorite technical b ookstore,  SoftPro in Burlington, Massa chusetts, let me spend 
many hours there l ooking at their stock t o find how people use the UML in prac tice and fed me g ood 
coffee wh ile I was there. 
For the third edi tion, the acquisi tion ed itor was Mike Hendrickson. Kim Arney Mulcahy managed the 
project, as well as did the layout and clean-up of the diagrams. John F uller, at Addison-Wesley, was 
the producti on editor, while Evelyn Pyle and Rebecca Rider helped with the copyediting an d 
proofreading of the b ook. I thank them all. 
Cindy has stayed w ith me while I persist in wri ting books. She then plants the proceeds in the 
garden. 
My parents started me off with a good educa tion, from which all else springs. 
Martin Fowler 
Melrose, Massachusetts 
http://martinfowler.com  
 



10/118 Diagrams 
 



11/118 
 



12/118 
 



13/118 
 
 



14/118 Chapter 1. Introduction 
What Is  the UML?  
Ways of Using the UML  
How We Got t o the UML  
Notations and Meta-Mode ls 
UML Diagrams  
What Is Legal UML?  
The Meaning of UML  
UML Is Not Enough  
Where t o Start with  the UML  
Where to Find Out More  
What Is the UML? 
The Unified Modeling Language (UML) is a fa mily of graphical notati ons, backed by single meta-
model, that help in describing and designing s oftware systems, particularly software systems buil t 
using the object-oriented (OO) style. That's a somewhat simplified def inition. In fact, the UML i s a 
few different t hings to different people. This comes both fr om its own history and from the differen t 
views that people have about what makes an e ffective software engineering process. As a res ult, my 
task in much of this chapter is to set the scene for this b ook by expla ining the different ways in 
which people see and use the UML. 
Graphical mode ling languages have been ar ound in the s oftware  industry for a long time. Th e 
fundamental driver behind them all is that programming languages are not at a high enough level of 
abstra ction to facilitate discussi ons about design. 
Despite the fact  that graphical modeling languages have been ar ound for a long time, there is a n 
enormous am ount of dispute in  the software industry about their role. These disputes play directly 
into how people perceive the role of the UML  itself. 
The UML is a relatively open standard, c ontrolled by the Object Management Group (OMG), an  open 
consor tium of companies. The OMG was formed to build standards  that supported interoperability, 
specifically  the interoperability of object-oriented systems. The OMG is perhaps best known for  the 
CORBA (Comm on Object Request Broker Architecture) standards. 
The UML was born out of the unifica tion of the many object-oriented graphical modeling languages 
that thrived in the late 1980s and early 1990s. Since its appearance in 1997, it has relegated tha t 
particular tower of Babel t o history. That's a s ervice I, and many other developers, am deeply 
thankful for. 
 
Where to Find Out More 



15/118 This b ook is not a complete and defi nitive reference t o the UML, let alone OO analysis and design. A 
lot of words are out there and a lot of worthwhile things t o read. As I discuss the  individual topics, I 
also men tion other books you should go t o for more in-depth informa tion there. Here are som e 
general b ooks on  the UML and object-oriented design. 
As with all b ook recommenda tions, you may need to check which version of  the UML they are 
written for. As of June 2003, no published b ook uses UML 2.0, which is hardly surpri sing, as the ink 
is barely dry on the standard. The b ooks I suggest are g ood books, but I can't tell whether or whe n 
they will be updated t o the UML 2 standard. 
If you are new to objects, I rec ommend my cu rrent favorite introductory b ook: [Larman]. The 
author's strong responsibility-driven approach to design is worth fo llowing. 
For the conclusive word on the UML, you sh ould look to the official standards d ocuments; bu t 
remember, they are written for c onsenting me thodologists in  the privacy of their own cubicles. For a 
much more dige stible version of the standard,  take a l ook at [Rumbaugh, UML Reference]. 
For more deta iled advice on object-oriented design, you'll learn many g ood things fr om [Mar tin]. 
I also suggest that you read b ooks on patterns  for material that will take y ou beyond the basics . 
Now that the methods war is over, patterns (page 27) are where most of the interesting materia l 
about analysis and design appears. 
 
Ways of Using the UML 
At the heart of the role of the UML in s oftware development are the different ways in which people 
want t o use it, differences that carry over from  other graphical mode ling languages. Thes e 
differences lead t o long and difficult argument s about how the UML should be used. 
To untangle this, Steve Mellor and I independen tly came up with a characterization of the thre e 
modes in which people use the UML: sketch, b lueprint, and programming language. By far the mos t 
comm on of the three, at least t o my biased eye, i s UML as sketch . In this usage, developers use 
the UML t o help c ommunicate s ome aspects of a system. As w ith blueprints, you can use sket ches in 
a forward-engineering or reverse-engineering direction. Forward engineering  draws a UML 
diagram before y ou write code, while reverse engineering  builds a UML diagram fr om existin g 
code in order to help  understand it. 
The essence of sketching is selectivity.  With forward sketching, you rough out some issues in  code 
you are ab out to write, usua lly discussing them with a group of people on your team. Your aim  is to 
use the sketches t o help c ommunicate ideas and alternatives ab out what you're ab out to do. Yo u 
don't talk ab out all the code you are g oing to work on, only important issues that you want to run 
past your c olleagues first or secti ons of the design that you want t o visualize before you begin 
programming. Sessions  like this can be very short: a 10-mi nute session to discuss a few hours of 
programming or a day to discuss a 2-week  iteration. 
With reverse engineering, you use sketches t o explain how some part of a system works. You don' t 
show every class, simply those that are  interesting and worth talking ab out before you dig into the 
code. 
Because sketching is pre tty informal and dyna mic, you need to do it quickly and c ollaboratively, so a 
comm on medium is a whiteboard. Sketches are als o useful in documents, in which case the focus is 
communica tion rather than completeness. The  tools used for sketching are  lightweight drawing 
tools, and often people aren't t oo particular about keeping to every strict rule of the UML. Mos t UML 
diagrams shown in b ooks, such as my other books, are sketches. Their emphasis is on selective 
communica tion rather than complete specifica tion. 



16/118 In contrast, UML as blueprint  is about completeness. In forward engineering, the idea is tha t 
blueprints are developed by a designer whose job is to bu ild a detailed design for a programmer t o 
code up. That design should be sufficiently complete in  that all design decisions are laid out, and the 
programmer sh ould be able to f ollow it as a pretty straightforward activity that requires  little 
thought. The designer may be the same person as the programmer, but usually the designer i s a 
more senior developer who designs for a team of programmers. The inspiration for this approach is 
other forms of engineering in which professional engineers create engineering drawings that ar e 
handed over t o construc tion companies to build . 
Blueprinting may be used for all details, or a designer may draw blueprints to a par ticular area. A 
comm on approach is for a designer to develop blueprint-level models as far as interfaces of 
subsystems but  then let developers work out  the details of implementing those details. 
In reverse engineering, blueprints aim to c onvey detailed informa tion ab out the code e ither in paper 
documents or as an interactive graphical browser. The blueprints can show every detail about a 
class in a graphical form  that's easier for developers to understand. 
Blueprints require much more sophisticated t ools than sketches d o in order t o handle  the deta ils 
required for the task. Specialized CASE (computer-aided s oftware engineering) t ools fall into this 
category, although the term CASE has become a dirty word, and vendors try to avoid it now. 
Forward-engineering t ools support diagram drawing and back it up with a repository t o hold th e 
informa tion. Reverse-engineering t ools read s ource code and interpret from  it into the rep ository 
and generate diagrams. T ools that can do b oth forward and reverse engineering like this are 
referred to as round-trip  tools. 
Some t ools use the s ource code itself as the repos itory and use diagrams as a graphic viewport  on 
the code. These t ools tie much more cl osely into programming and often integrate directly wit h 
programming ed itors. I  like to think of these as tripless  tools. 
The line between blueprints and sketches is s omewhat blurry, but  the distinc tion, I think, rests on 
the fact  that sketches are deliberately incomplete, high lighting important  information, while 
blueprints intend to be comprehensive, often with the aim of reducing programming to a simpl e and 
fairly mechanical activity. In a s ound bite, I'd say that sketches are explorative, while blueprin ts are 
definitive. 
As you d o more and more in the UML and the programming gets increasingly mechanical,  it 
becomes obvious that  the program ming sh ould be automated. Indeed, many CASE t ools do s ome 
form of code generation, which automates bu ilding a significant part of a system. Eve ntually, 
however, you reach the p oint at which all the system can be specified in the UML, and you rea ch 
UML as progra mming language . In this environment, developers draw UML diagrams that are 
compiled directly to executable code, and the UML becomes the source code. Obviously,  this usage 
of UML demands particularly sophis ticated t ooling. (Also, the n otions of forward and reverse 
engineering don't make any sense for this mode, as the UML and source code are the same t hing.) 
Model Driven Arquitect ure and Executable UM L 
When people talk about the UML, they also often talk ab out Model Driven Architecture  
(MDA) [Kleppe et al.]. Essentially, MDA is a standard approach t o using the UML as a 
programming language;  the standard is c ontrolled by  the OMG, as is the UML. By 
producing a modeling environment that confo rms to the MDA, vendors can create models 
that can also work w ith other MDA-c ompliant envir onments. 
MDA is often talked ab out in the same breath as the UML because MDA uses the UML as 
its basic mode ling language. But, of course, you don't have to be using MDA t o use the 
UML. 
MDA divides development work into two main areas. Modelers represent a particula r 
application by crea ting a Platform Independent Model  (PIM). The PIM is a UML mode l 
that is  independent of any pa rticular technology. T ools can then turn a PIM  into a 
Platform Specific Model  (PSM). The PSM is a model of a system targeted to a specifi c 



17/118 executi on environment. Further t ools then take the PSM and generate code for tha t 
platform. The PSM c ould be UML but doesn't have to be. 
So if you want to build a warehousing system using MDA, you w ould start by crea ting a 
single PIM of your wareh ousing system. If y ou then wanted  this wareh ousing system t o 
run on J2EE and .NET, y ou would use some vendor t ools to create two PSMs: one for eac h 
platform. Then fu rther tools would generate code for the two platforms. 
If the process of going from PIM to PSM to final code is completely automated, we have 
the UML as programming language. If any of the steps is manual, we have blueprints. 
Steve Me llor has long been ac tive in this kind of work and has recently used the term 
Executable U ML [Mellor and Balcer]. Executable UML is similar to MDA but uses slightly 
different terms.  Similarly, y ou begin with a plat form-independent model that is equivalen t 
to MDA's PIM. However,  the next step is t o use a Model Compiler to turn that UML mode l 
into a deployable system in a single step; hence, there's n o need for the PSM. As the term 
compiler  suggests, this step is completely automatic. 
The model compilers are based on reusable ar chetypes. An archetype  describes how t o 
take an exe cutable UML model and turn it into a particular programming platform. S o for 
the warehou sing example, you w ould buy a model compiler and two archetypes ( J2EE an d 
.NET). Run each archetype on your executable UML model, and y ou have your tw o 
versions of the warehou sing system. 
Executable UML does not use the f ull UML standard; many constructs of UML are 
considered to be unnecessary and are therefore not used. As a res ult, Exe cutable UML is 
simpler than full UML. 
All this s ounds g ood, but how realistic is it? In  my view, there are tw o issues here. First i s 
the ques tion of the t ools: whether they are mature enough to d o the job. This is 
something  that changes over time; certainly,  as I write this, they aren't widely used, and I 
haven't seen much of them in ac tion. 
A more fundamental issue is the wh ole notion of the UML as a programming language. In 
my view,  it's worth u sing the UML as a progr amming language only if  it results i n 
something  that's significantly more produ ctive than using an other programming language . 
I'm not con vinced that it is, based on various graphical development envir onments I'v e 
worked with in  the past. Even if it is more productive, it still needs to get a c ritical mass of 
users for it to make the mainstream. That's a big hurdle in itself. Like many old 
Smalltalkers, I consider Smal ltalk to be much  more produ ctive than current mainstrea m 
languages. But as Smalltalk is now only a nich e language, I don't see many pr ojects u sing 
it. To avoid Smal ltalk's fate, the UML has to be luckier, even if  it is superior. 
 
One of the interesting questions ar ound the UML as programming language is how to mode l 
behavioral logic. UML 2 offers three ways of behavioral modeling:  interacti on diagrams, stat e 
diagrams, and activity diagrams. All have their proponents for programming in. If  the UML does gain 
popularity as a programming language, it will be interesting to see which of these techniques 
become successful. 
Another way  in which people l ook at the UML i s the range between using it for conceptual and for 
software modeling. M ost people are fami liar with the UML used for software modeling.  In this 
software perspective , the elements of the UML map pretty directly to elements in a software 
system. As we shall see, the mapping is by n o means prescriptive, but when we use the UML, we 
are talking ab out software elements. 
With the conceptual perspective , the UML represents a descripti on of the c oncepts of a domain of 
study. Here, we aren't talking ab out software elements s o much as we are bu ilding a vocabulary t o 
talk ab out a particular domain. 



18/118 There are n o hard-and-fast rules ab out perspe ctive; as it turns out, there's really quite a large range 
of usage. S ome tools automatically turn source code int o the UML diagrams, treating the UML as a n 
alternative view of the s ource. That's very mu ch a software perspective. If y ou use UML diagrams t o 
try and understand the vari ous meanings of the terms asset p ool with a bunch of accountants,  you 
are in a much more conceptual frame of mind. 
In previous editions of this b ook, I sp lit the s oftware perspective into specification (interface) and 
implementation.  In practice, I found that it was t oo hard to draw a precise line between the two, s o 
I feel that the distinc tion is n o longer worth making a fuss ab out. However, I'm always inclined to 
emphasize interface rather  than implementa tion in my diagrams. 
These different ways of using  the UML lead to a host of arguments about what UML diagrams mean 
and what  their rela tionship is t o the rest of th e world. In pa rticular,  it affects  the rela tionship 
between the UML and source code. Some people hold the view that the UML should be used t o 
create a design that is independent of the programming language that's used for implementa tion. 
Others believe that language-independent design is an oxymoron, with a strong emphasis on  the 
moron. 
Another difference in viewp oints is what the essence of the UML is.  In my view, most users of the 
UML, particularly sketchers, see the essence of the UML to be the diagrams. However, the creators 
of the UML see the diagrams as secondary; the essence of the UML is  the meta-model. Diagr ams are 
simply a presenta tion of the meta-model. This view als o makes sense to blueprinters and UML 
programming language users. 
So whenever you read anything involving the  UML, it's important t o understand the p oint of view of 
the author. Only then can y ou make sense of the often fierce arguments that the UML encourages. 
Having said all  that, I need t o make my biases  clear. Almost all the time, my use of the UML is as 
sketches. I find the UML sketches useful with forward and reverse engineering and in bot h 
conceptual and software perspectives. 
I'm not a fan of detailed forward-engineered b lueprints; I be lieve that  it's too difficult to do well and 
slows down a development effort. Blueprinting to a level of subsystem interfaces is reasonable, bu t 
even then you sh ould expect to change th ose interfaces as developers implement  the interactions 
across the interface. The value of reverse-eng ineered bluepr ints is dependent on how the t ool 
works. If it's used as a dynamic browser,  it can be very helpful; if it generates a large document, al l 
it does is kill trees. 
I see the UML as progra mming language as a nice idea but doubt that it will ever see significan t 
usage. I'm n ot convinced that graphical forms are more productive than textual forms for mos t 
programming tasks and that even if they are,  it's very difficult for a language t o be widely accepted. 
As a result of my biases, this b ook focuses m uch more on using the UML for sketc hing. Fortunately, 
this makes sense for a brief guide. I can't do justice to the UML in its other modes in a b ook this 
size, but a b ook this size makes a g ood introduc tion to other b ooks that can. So if you're inter ested 
in the UML in  its other modes, I'd suggest that you treat this b ook as an introduction and move  on 
to other books as you need them. If you're  interested only in sketches, this book may well be a ll you 
need. 
 
How We Got to the UML 
I'll adm it, I'm a history buff. My favorite idea of light reading is a g ood history b ook. But I also know 
that it's not everybody's idea of fun. I talk ab out history here because I  think that in many ways, it's 
hard t o understand where the UML is without understanding the  history of how it got here. 



19/118 In the 1980s, objects began to m ove away fr om the research labs and t ook their first steps toward 
the "real" world. Smal ltalk stabilized into a plat form that people could use, and C++ was born. A t 
that time, various people started thin king ab out object-oriented graphical design languages. 
The key b ooks about object-oriented graphical modeling languages appeared between 1988 and 
1992. Leading figures included Grady B ooch [Booch, OOAD]; Peter Coad [Coad, OOA], [Coad, 
OOD]; Ivar Jacobson (Objectory) [Jacobson, OOSE]; Jim Odell [Odell]; Jim Rumbaugh (OMT ) 
[Rumbaugh, insights], [Rumbaugh, OMT]; Sall y Shlaer and  Steve Mellor [Shlaer and Mellor, data], 
[Shlaer and Mellor, states]; and Rebecca Wirfs-Brock (Resp onsibility Driven Design) [Wirfs-Br ock]. 
Each of  those authors was now informally leading a group of practiti oners wh o liked th ose ideas. Al l 
these methods were very sim ilar, yet they c ontained a number of often ann oying minor differe nces 
among them. The same basic c oncepts w ould appear in very different nota tions, which caused 
confusion to my clients. 
During  that heady time, standardization was a s talked ab out as it was ignored. A team from the 
OMG tried to l ook at standardizati on but got only an open letter of protest fr om all the key 
methodologists. (This reminds me of an old joke. Question:  What is the difference between a 
methodologist and a terrorist? Answer: You ca n negotiate w ith a terrorist.) 
The cataclysmic event that first  initiated the UML was when Jim Rumbaugh left GE to join Grad y 
Booch at Ra tional (now a part of IBM). The B ooch/Rumbaugh al liance was seen from the beginning 
as one that c ould get a critical mass of market share. Grady and Jim proclaimed that "the methods 
war is over we won," basically declaring that  they were g oing to achieve standardization "the 
Micros oft way." A number of other methodologists suggested forming an A nti-Booch Coalition. 
By OOPSLA '95, Grady and Jim had prepared their first public descripti on of their merged method: 
version 0.8 of th e Unified Meth od documentation. Even more significant, they ann ounced tha t 
Rational S oftware had bought Objectory and that therefore, Ivar Jacobson w ould be joining th e 
Unified team. Rational held a we ll-attended pa rty to celebrate the release of the 0.8 draft. (The 
highlight of the party was the first public display of Jim Rumbaugh's singing; we all hope it's also the 
last.) 
The next year saw a more open process emerge. The OMG, which had mostly st ood on the side lines, 
now t ook an active role. Rational had to incorporate Ivar's ideas and also spent time with other 
partners. More important, the OMG decided t o take a ma jor role. 
At this point, it's important to realize why  the OMG g ot involved. Methodologists, like b ook authors, 
like to think that they are important. But I don't think  that the screams of b ook authors would eve n 
be heard by the OMG.  What got the OMG  involved were  the screams of tools vendors, all of w hich 
were frightened that a standard contr olled by Ra tional would give Ra tional t ools an unfair 
competitive advantage. As a result, the vendor s energized the OMG to do some thing ab out it, under 
the banner of CASE t ool interoperability. This banner was important, as the OMG was all ab out 
interoperability. The idea was to create a UML that would allow CASE t ools to freely exchange 
models. 
Mary L oomis and Jim Odell chaired  the initial task force. Odell made it clear that he was prepared t o 
give up his method to a standard, but he did n ot want a Ra tional-imp osed standard. In Januar y 
1997, various organizations submitted proposals for a methods standard t o facilitate the interchange 
of models. Ra tional co llaborated with a numbe r of other organizations and released version 1.0  of 
the UML d ocumentati on as their proposal, the first animal to answer to the name Unified Model ing 
Language. 
Then fo llowed a short period of arm twisting w hile the vari ous proposals were merged. The OM G 
adopted the re sulting 1.1 as an official OMG standard. Some revisions were made later on. Re vision 
1.2 was entirely cosmetic. Revisi on 1.3 was more significant. Revision 1.4 added a number of 
detailed concepts ar ound comp onents and prof iles. Revision 1.5 added action seman tics. 
When people talk about the UML, they credit mainly Grady B ooch, Ivar Jacobson, and Jim 
Rumbaugh as  its creators. They are generally referred to as the Three Amigos, although wags like t o 



20/118 drop the first sy llable of the second word. A lthough they are m ost credited with  the UML, I  think it 
somewhat unfair to give them the d ominant cred it. The UML notation was first formed  in the 
Booch/Rumbaugh Unified Method. Since then, much of  the work has been led by OMG committees. 
During  these later stages, Jim Rumbaugh is the  only one of the three to have made a heavy 
commitment. My view is  that it's these members of the UML com mittee process that deserve the 
principal credit for the UML. 
 
Notations and Meta-Models 
The UML, in  its current state, defines a nota tion and a meta-model. The notati on is the graphica l 
stuff y ou see in models; it is the graphical syntax of the modeling language. For instance, class 
diagram notation defines how items and concepts, such as class, associa tion, and multiplicity, are 
represented. 
Of course,  this leads t o the questi on of what exactly is meant by an association or mul tiplicity or 
even a class. Common usage suggests some i nformal def initions, but many people want more rigor 
than that. 
The idea of rigorous specification and design languages is m ost prevalent in the field of forma l 
methods. In such techniques, designs and specificati ons are represented using some derivative of 
predicate calculus. Such definiti ons are math ematically rigor ous and a llow no ambiguity. However, 
the value of these definiti ons is by no means universal. Even if you can prove  that a program 
satisfies a mathematical specifica tion, there is  no way to prove that  the mathematical specificat ion 
meets the real requirements of the system. 
Most graphical modeling languages have very little rigor; their notation appeals t o intuition rather 
than to formal definition. On the wh ole, this does not seem t o have done much harm. These 
methods may be informal, but many people still find them useful—and it is use fulness that counts. 
However, methodologists are l ooking for ways  to impr ove the rigor of methods without sacrifi cing 
their usefulness. One way to do this is to de fine a meta-model:  a diagram, usually a class diagram, 
that defines the concepts of  the language. 
Figure 1.1 , a small piece of the UML meta-model, shows the relation ship among features. (Th e 
extract is there to give you a flavor of what meta-models are  like. I'm n ot even going t o try to 
explain it.) 
Figure 1.1. A small piece of the UML meta-model 



21/118 
 
How much does the meta-model affect a user of the modeling notation? The answer depends mostly 
on the mode of usage. A sketcher usually doesn't care t oo much; a bluepr inter should care rather 
more. It's vitally important t o those who use  the UML as a programming language, as it defines the 
abstract syntax of  that language. 
Many of the people who are involved in the ongoing development of the UML are interested primaril y 
in the meta-model, particularly as this is important t o the usage of the UML and a programmin g 
language. Notational issues often run second place, which is important to bear in mind if you e ver 
try to get familiar with  the standards documen ts themselves. 
As you get deeper int o the more deta iled usage  of the UML, y ou realize that you need  much more 
than the graphical notation. This is why UML t ools are s o complex. 
I am not rigorous in this b ook. I prefer the trad itional methods path and appeal mainly t o your 
intuition. That's natural for a small b ook like this wri tten by an author who's in clined m ostly to a 
sketch usage. If you want more rigor, y ou should turn t o more detailed tomes. 
UML Diagrams 
UML 2 describes 13 official diagram types listed i n Table 1.1  and classified as  indicated on Figure 
1.2. Although these diagram types are the wa y many people approach the UML and how I've 
organized this book, the UML's a uthors d o not see diagrams as  the central part of  the UML. As a 
result, the diagram types are not particularly rigid. Often, you can legally use elements from on e 
diagram type on another diagram. The UML standard indicates that certain elements are typically 
drawn on certain diagram types, but this is n ot a prescrip tion. 
Figure 1.2. Classification of UML diagram types 



22/118 
 
Table 1.1. Official Diagram Types of the UML 
Diagra m Book 
Chapters Purpose Lineage 
Activity 11 Procedural and parallel behavior In UML 1 
Class 3, 5 Class, features, and relati onships In UML 1 
Communication 12 Intera ction between objects; emphasis 
on links UML 1 c ollaboration 
diagram 
Component 14 Structure and c onnections of 
components In UML 1 
Compos ite 
structure 13 Runtime decomp osition of a class New to UML 2 
Deployment 8 Deployment of artifacts t o nodes In UML 1 



23/118 Table 1.1. Official Diagram Types of the UML 
Diagra m Book 
Chapters Purpose Lineage 
Intera ction 
overview 16 Mix of sequence and activity diagram New to UML 2 
Object 6 Example c onfigura tions of instances Un officially in UML 1 
Package 7 Comp ile-time hierarchic structure Un officially in UML 1 
Sequence 4 Intera ction between objects; emphasis 
on sequence In UML 1 
State machine 10 How events change an object over its 
life In UML 1 
Timing 17 Intera ction between objects; emphasis 
on timing New to UML 2 
Use case 9 How users interact with a system In UML 1 
 
What Is Legal UML? 
At first blush, this sh ould be a simple que stion to answer: Legal UML is what is defined as wel l 
formed  in the specifica tion. In prac tice, however, the answer is a bit more complicated. 
An important part of  this questi on is whether the UML has descriptive or prescriptive rules. A 
language with prescriptive rules  is controlled by an official body that states what is or isn't legal i n 
the language and what meaning y ou give to utterances in that language. A language with 
descriptive rul es is one in which you understand its rules by l ooking at how people use th e 
language  in practice. Program ming languages tend to have prescriptive rules set by a standards 
committee or d ominant vendor, while natural languages, such as English, tend t o have descriptive 
rules whose meaning is set by c onvention. 
UML is q uite a precise language, s o you might expect it t o have prescriptive rules.  But UML is often 
considered to be the software equivalent of the blueprints in other engineering disciplines, and  these 
blueprints are not prescriptive nota tions. No committee says what the legal symbols are on a 
structural engineering drawing;  the nota tion has been accepted by conven tion, sim ilarly to a natura l 
language. Simply having a standards body doesn't d o the trick e ither, because people in the field 
may not f ollow every thing the standards body  says; just ask the French ab out the Académie 
Française.  In addition, the UML is so complex that the standard is often open t o multiple 
interpreta tions. Even  the UML leaders who reviewed this b ook would disagree on interpreta tion of 
the UML standard. 
This issue is important b oth for me writing this book and for you using  the UML. If y ou want t o 
understand a UML diagram, it's important t o realize that understanding the UML standard is n ot the 
whole picture. People do adopt c onventions, b oth in the  industry widely and w ithin a particular 
project. As a result, although the UML standar d can be the primary s ource of informati on on the 
UML, it can't be the only one. 
My att itude is  that, for m ost people,  the UML has descriptive rules. The UML standard is the bigges t 
single influence on what UML means, but it isn't the only one. I think that this will becom e 
particularly true with UML 2, which introduces some notational conventi ons that conflict with e ither 
UML 1's definiti on or the c onventional usage of UML, as well as adds yet more complexity to th e 
UML. In this book, therefore, I'm trying t o summarize the UML as I find it: both the standard s and 
the conventional usage.  When I have to make a dis tinction in this book, I'll use the ter m 
conventional use  to indicate some thing that isn't in the standard but  that I think is widely used. 
For something that conforms to the standard, I'll use  the terms standard  or normative . 
(Normative is the term standards people use t o mean a statement that you must conform to be 



24/118 valid in  the standard. So non-normative UML i s a fancy way of saying that something is strictly 
illegal according to the UML standard.) 
When y ou are looking at a UML diagram, y ou should bear in mind that a general principle in  the UML 
is that any information may be suppressed  for a particular diagram. This suppressi on can occu r 
either genera lly—hide all a ttributes—or specifica lly—don't show these three classes. In a diagram, 
therefore, y ou can never infer anything by its absence. If a m ultiplicity is mis sing, you cannot i nfer 
what value it might be. Even if the UML meta -model has a default, such as [1] for attributes, i f you 
don't see the informati on on the diagram, it may be because it's the default or because it's 
suppressed. 
Having said that, there are some general conventions, such as  multivalued properties being sets. In 
the text, I'll point out these default c onventions. 
It's important t o not put t oo much emphasis on having legal UML if you're a sketcher or bluepr inter. 
It's more  important t o have a g ood design for your system, and I w ould rather have a g ood design 
in illegal UML than a legal but p oor design. Ob viously, g ood and legal is best, but you're be tter off 
putting your energy into having a g ood design  than worrying ab out the arcana of UML. (Of course, 
you have to be legal  in UML as program ming language, or your program won't run properly!) 
 
The Meaning of UML 
One of the awkward issues ab out the UML is that, a lthough the specifica tion describes in great detai l 
what well-formed UML is, it doesn't have much to say ab out what the UML means outside of th e 
rarefied world of  the UML meta-model. No fo rmal definition exists of how the UML maps to any 
particular programming language. Y ou cann ot look at a UML diagram and say exact ly what th e 
equivalent code would l ook like. However, you can get a rough idea  of what the code would l ook 
like. In practice, that's enough to be useful. D evelopment teams often form their local c onventions 
for these, and you'll need to be familiar with  the ones in use. 
UML Is Not Enough 
Although the UML pr ovides q uite a considerabl e body of vari ous diagrams that help to define an 
application, it's by n o means a complete list of all the useful diagrams that you might want t o use. 
In many places, different diagrams can be useful, and y ou shouldn't hes itate to use a non-UML 
diagram if no UML diagram suits y our purpose. 
Figure 1.3 , a screen flow diagram, shows the various screens on a user interface and how you move 
between them. I've seen and used  these screen flow diagrams for many years. I've never seen more 
than a very rough defi nition of what they mean; there isn't any thing like it in the UML, yet I've 
found it a very use ful diagram. 
Figure 1.3. An informal screen flow diagram for part of the wiki 
(http: //c2.com/cgi/wi ki) 



25/118 
 
Table 1.2  shows another favorite: the decision  table. Decision tables are a g ood way to show 
complicated logical cond itions. Y ou can do this with an activity diagram, but once you get beyond 
simple cases, the table is both more compact and more clear. Again, many forms of decision tables 
are out there. Table 1.2  divides the table int o two secti ons: condi tions above the double  line an d 
consequences below it. Each c olumn shows how a par ticular combinati on of cond itions leads t o a 
particular set of consequences. 
Table 1.2. A Decision Table 
Premium customer X X Y Y N N 
Priority order Y N Y N Y N 
International order Y Y N N N N 
Fee $150 $100 $70 $50 $80 $60 
Alert rep • • •       
You'll run into various kinds of these things in  various b ooks. Don't hes itate to try out techniques 
that seem appropriate for your pr oject. If the y work well, use  them. If not, discard them. (This is, of 
course, the same advice as for UML diagrams.) 
 
Where to Start with the UM L 
Nobody, not even the creators of the UML, un derstand or use all of it. Most people use a smal l 
subset of the UML and work with that. Y ou have to find the subset of the UML that works for you 
and your colleagues. 
If you are starting out, I suggest that y ou concentrate first on the basic forms of class diagram s and 
sequence diagrams. These are  the most common and, in my view, the m ost useful diagram types. 



26/118 Once you've g ot the hang of those, you can st art using some of the more advanced class diagram 
notati on and take a l ook at the other diagrams types. Experiment with  the diagrams and see how 
helpful  they are to you. Don't be afraid t o drop any  that don't seem be useful t o your work. 
 
Chapter 2. Development Process 
As I've already men tioned, the UML grew out of a bunch of OO analysis and design methods. T o 
some extent, all of them mixed a graphical modeling language with a pr ocess that described how t o 
go about developing s oftware. 
Interestingly, as the UML was formed, the various players discovered that although they could agree 
on a modeling language, they m ost certainly could not agree on a process. As a re sult, they a greed 
to leave any agreement on pr ocess un til later and to confine the UML to being a modeling language. 
The title of this book is UML Distilled , so I coul d have safely ignored process. However, I don' t 
believe  that modeling techniques make any se nse without knowing how  they fit  into a process. The 
way y ou use the UML depends a l ot on the styl e of process you use. 
As a result, I think that it's important to talk about process first s o that you can see the c ontext for 
using the UML. I'm not g oing to g o into great detail on any particular process; I simply want to give 
you enough informa tion to see this context and pointers to where y ou can find out more. 
When y ou hear people discuss the UML, you often hear them talk ab out the Rational Unified Process 
(RUP). RUP is one process—or, more strictly, a process framework—that you can use with the UML. 
But other than the c ommon involvement of var ious people from Ra tional and the name "unified," i t 
doesn't have any special relation ship to the UML. The UML can be used with any process. RUP is a 
popular approach and is discussed on page 25. 
 
Iterative and Waterfall Processes 
One of the biggest debates about process is that between waterfall and iterative styles. The terms 
often get misused, par ticularly as iterative is seen as fa shionable, while the waterfall process seems 
to wear plaid trousers. As a re sult, many pr ojects claim to do iterative development but are really 
doing waterfall. 
The essen tial difference between the two is how you break up a pr oject into smaller c hunks. If you 
have a pr oject that you t hink will take a year, few people are comfortable tel ling the team to g o 
away for a year and t o come back when d one. Some breakdown is needed s o that people can 
approach the problem and track progress. 
The waterfall  style breaks down a pr oject based on a ctivity. To build software, y ou have to d o 
certain activi ties: requirements analysis, design, coding, and testing. Our 1-year pr oject might thus 
have a 2-m onth analysis phase, fo llowed by a 4-month design phase, fo llowed by a 3-month codin g 
phase, f ollowed by a 3-m onth tes ting phase. 
The iterative  style breaks down a pr oject by subsets of func tionality. You might take a year and 
break it int o 3-month iterations. In  the first itera tion, you'd take a quarter of the requirements and 
do the complete software life cycle for that qu arter: analysis, design, code, and test. At the end  of 
the first iteration, you'd have a system that does a quarter of the needed functionality. Then you'd 
do a second iteration so that at the end of 6 months, you'd have a system that does half the 
functionality. 



27/118 Of course,  the above is a simplified descrip tion, but it is  the essence of the difference. In prac tice, of 
course, some impuri ties leak int o the process. 
With waterfall development, there is usually some form of formal handoff between each phase, bu t 
there are often backflows. During coding, something may come up  that causes y ou to revisit the 
analysis and design. You certainly sh ould not assume that all design is finished when coding begins. 
It's inev itable that analysis and design decisions will have t o be revisited  in later phases. However, 
these backflows are excepti ons and sh ould be minimized as much as p ossible. 
With iteration, you usually see some form of exploration activity before the true itera tions begin. A t 
the very least, this will get a high-level view of the requirements: at least enough to break the 
requirements down int o the iterations that will follow. S ome high-level design decisions may occur 
during exploration t oo. At the other end, although each  iteration sh ould produce production-ready 
integrated software, it often doesn't q uite get to that point and needs a stabiliza tion period to iron 
out the last bugs. Also, some activities, such as user training, are left to the end. 
You may well not put the system into producti on at the end of each iteration, but the system shoul d 
be of produc tion quality. Often, however, you can put the system into producti on at regula r 
intervals; this is g ood because you get value from the system earlier and you get better-qualit y 
feedback. In this s ituation, you often hear of a pr oject having mul tiple releases , each of which is 
broken down into severa l iteratio ns. 
Iterative development has come under many names:  incremental, spiral, evolu tionary, and jacuzz i 
spring to mind. Vari ous people make di stinctions among them, but the distinc tions are neithe r 
widely agreed on nor that important compared  to the iterative/waterfall dichotomy. 
You can have hybrid approaches. [McC onnell] describes  the staged delivery  life cycle where by 
analysis and high-level design are d one first, i n a waterfall style, and then the coding and test ing are 
divided up int o iterations. Such a pr oject might have 4 m onths of analysis and design f ollowed by 
four 2-month iterative builds of the system. 
Most wr iters on s oftware process in  the past few years, especially in the object-oriented com munity, 
dislike the waterfall approach. Of  the many re asons for this, the m ost fundamental is that it's very 
difficult t o tell whether the pr oject is truly on track w ith a waterfall pr ocess. It's t oo easy to declare 
victory with early phases and hide a schedule s lip. Usually,  the only way you can rea lly tell whether 
you are on track is to produce tested, integrated software. By d oing this repeatedly, an iterativ e 
style gives you better wa rning if s omething is going awry. 
For that reason alone, I strongly recommend  that projects d o not use a pure waterfall approa ch. You 
should at least use staged delivery, if not a more pure iterative technique. 
The OO com munity has long been  in favor of iterative development, and  it's safe to say that pretty 
much everyone inv olved in building  the UML is in favor of at least some form of iterative 
development. My sense of industrial practice is  that waterfall development is still the more c ommon 
approach, however. One reason for this is what I refer to as pseud oiterative development: People 
claim to be doing iterative development but are in fact d oing waterfall. C ommon sympt oms of this 
are: 
• "We are d oing one analysis iterati on followed by two design iterations. . . ." 
• "This iteration's code is very buggy, but we'll clean it up at  the end." 
It is parti cularly important that each itera tion produces tested, integrated code that is as cl ose to 
produc tion quality as possible. Testing and  integra tion are the hardest activities to estimate, s o it's 
important not t o have an open-ended ac tivity like that at the end of the pr oject. The test sh ould be 
that any  iteration that's not scheduled to be released could be released with out substantial extr a 
development work. 
A common technique with itera tions is t o use time boxing . This forces an iteration to be a fi xed 
length of  time. If it appears that you can't build a ll you intended to bu ild during an iteration, y ou 
must decide to s lip some fun ctionality from  the iteration; you must n ot slip the date of the iteration. 



28/118 Most pr ojects that use iterative development use the same itera tion length throughout the pr oject; 
that way, y ou get a regular rhythm of builds. 
I like time b oxing because people usually have difficulty slipping functionality. By practicing slipping 
function regularly, they are in a better posi tion to make an  intelligent choice at a big release 
between slipping a date and s lipping function.  Slipping func tion during itera tions is als o effectiv e at 
helping people learn what the real requirements priorities are. 
One of the m ost common concerns about iterative development is  the issue of rework. Iterative 
development explicitly assumes that you will be reworking and deleting exis ting code during th e 
later iterations of a pr oject. In many domains,  such as manufacturing, rework is seen as a waste. 
But software isn't like manufacturing; as a result, it often is more efficient to rework exi sting code 
than to patch ar ound code that was p oorly designed. A number of technical practices can greatl y 
help make rework be more efficient. 
• Automated regression tests  help by a llowing you to quickly detect any defects that may 
have been introduced when you are changing things. The xUnit family of te sting framework s 
is a particularly valuable t ool for building aut omated u nit tests. Sta rting with the origina l 
JUnit http://junit.org , there are now ports t o almost every language imaginable (se e 
http://www.xprogra mming.com/software.htm ). A g ood rule of thumb is that the size 
of your unit test code sh ould be ab out the same size as your producti on code. 
• Refactoring  is a disciplined technique for changing existing software [Fowler, refactoring]. 
Refactoring works by u sing a series of small behavior-preser ving transformations t o the cod e 
base. Many of  these transforma tions can be au tomated (see 
http://www.refactoring.com ). 
• Continuous integration  keeps a team in sync to avoid painful integration cycles [Fowler 
and Foemmel]. At  the heart of this lies a fully automated build pr ocess that can be kicked off 
automatically whenever any member of the team checks code into the code base. Developer s 
are expected to check in daily, so automated builds are d one many times a day. The bu ild 
process  includes ru nning a large block of automated regression tests so that any 
inconsistencies are caught quickly so they can be fixed easily. 
All these te chnical practices have been popularized recently by Extreme Programming [Beck], 
although they were used before and can, and should, be used whether or n ot you use XP or any 
other agile process. 
 
Predictive and Adaptive Planning 
One reas on that the waterfall endures is the desire for predictab ility in software development. 
Nothing is more frustra ting than n ot having a clear idea how much it will cost to build some software 
and how long it will take to bu ild it. 
A predictive approach l ooks to do work early  in the project in order t o yield a greater  understandin g 
of what has to be done later. This way, y ou can reach a p oint where  the latter part of the pr oject 
can be estimated with a reasonable degree of accuracy. W ith predictive planning , a pr oject has 
two stages. The first stage comes up w ith plan s and is diffi cult to predict, but the second stage is 
much more predictable because  the plans are in place. 
This isn't necessarily a black-and-white affair. As the pr oject goes on, y ou gradually get mor e 
predictability. And even once you have a predi ctive plan, things w ill go wrong. You simply exp ect 
that the devia tions become less significant once a solid plan is in place. 
However,  there is a considerable debate ab out whether many software pr ojects can ever b e 
predictable. At  the heart of this ques tion is req uirements analysis. One of the unique sources of 
complexity  in software pr ojects is the difficulty in understanding the requirements for a software 
system. The ma jority of software pr ojects experience significan t requirements churn : changes i n 
requirements in the later stages of the pr oject. These changes shatter the foundations of a 



29/118 predictive plan. You can combat these changes by freezing  the requirements early on and no t 
permitting changes, but this runs the risk of delivering a system that n o longer meets the needs of 
its users. 
This problem leads to tw o very different reac tions. One r oute is to put more effort into the 
requirements process itself. This way, you ma y get a more accurate set of requirements, whic h will 
reduce the churn. 
Another sch ool contends that requirements ch urn is unavoidable, that it's too difficult for many 
projects to stab ilize requirements sufficiently t o use a predictive plan. This may be e ither owing t o 
the sheer diffic ulty of envisioning what s oftware can do or because market condi tions force 
unpredictable changes. This sch ool of thought advocate s adaptive planning , whereby predictiv ity 
is seen as an  illusion. Instead of f ooling ourselves with illusory predictability, we sh ould face the 
reality of constant change and use a pla nning approach that treats change as a c onstant in a 
software pr oject. This change is controlled s o that the pr oject de livers the best s oftware it can; bu t 
although the pr oject is contro llable, it is not predictable. 
The difference between a predictive pr oject an d an adaptive pr oject surfaces in many ways tha t 
people talk ab out how the pr oject goes.  When people talk ab out a pr oject that's d oing well because 
it's going according to plan, that's a predictive  form of t hinking. You can't say "according to plan" in 
an adaptive envir onment, because  the plan is always changing. This doesn't mean  that adaptiv e 
projects don't plan; they usually plan a lot, but  the plan is treated as a baseline to assess the 
consequences of change rather  than as a predi ction of the f uture. 
With a predictive plan, you can develop a fixed-price/fixed-scope contract.  Such a contract sa ys 
exactly what sh ould be bui lt, how much it will cost, and when it will be delivered.  Such fixing isn' t 
possible with an adaptive plan. Y ou can fix a budget and a time for delivery, but y ou can't fix wha t 
functionality will be delivered. An adaptive c ontract assumes that the users will c ollaborate wit h the 
development team to regularly reassess what func tionality needs to be b uilt and wi ll cancel th e 
project if progress ends up being t oo slow. As  such, an adaptive planning process can be fixed 
price/variable scope. 
Naturally, the adaptive approach is less desirable, as any one would prefer greater predictability in a 
software pr oject. However, predictab ility depends on a precise, accurate, and stable set of 
requirements. If y ou cannot stabilize your requirements, the predictive plan is based on sand and 
the chances are high  that the pr oject goes off course. This leads to tw o important pieces of advice. 
1. Don't make a predictive plan until you have precise and accurate requirements and are 
confident  that they won't significantly change. 
2. If you can't get precise, accurate, and stable requirements, use an adaptive plan ning style. 
Predictivity and adaptivity feed int o the choice of life cycle. An adaptive plan abs olutely require s an 
iterative process. Predictive planning can be done e ither way, although it's easier to see how i t 
works w ith waterfall or a staged delivery approach. 
 
Agile Processes 
In the past few years,  there's been a l ot of interest  in agile software processes. Agile is an umbre lla 
term that covers many pr ocesses that share a common set of values and principles as defined by 
the Manifesto of Agile Software Development ( http://agileManifesto.org ). Examples of thes e 
processes are Extreme Programming (XP), Sc rum, Feature Driven Development (FDD), Crystal, and 
DSDM (Dynamic Systems Development Method). 
In terms of our discussion, agile pr ocesses are strongly adaptive in their nature. They are also very 
much people-oriented processes. Ag ile approa ches assume that the m ost important factor in a 
project's success is the quality of  the people on the pr oject and how well they work together i n 
human terms. Which process  they use and which t ools they use are stri ctly sec ond-order effec ts. 



30/118 Agile methods tend t o use short, time-boxed itera tions, most often of a m onth or less. Becaus e they 
don't a ttach much weight to d ocuments, ag ile approaches disdain using the UML in blueprint mode. 
Most use  the UML in sketch mode, with a few advocating u sing it as a programming language. 
Agile processes tend to be low in ceremony . A high-ceremony, or heavyweight, pr ocess has a  lot of 
documents and control points during the pr oject. Agile processes consider that cerem ony makes i t 
harder t o make changes and works against  the grain of talented people. As a re sult, agile pr ocesses 
are often characterized a s lightweight . It's important to rea lize that the lack of cerem ony is a 
consequence of adap tivity and people orienta tion rather than a fundamental property. 
 
Rational Unified Process 
Although the Rational Unified Process (RUP) is  independent of  the UML, the two are often talked 
about together. S o I think it's worth saying a few t hings about it here. 
Although RUP is ca lled a process, it actually is a process framework, pr oviding a vocabulary and 
loose structure t o talk about processes.  When you use RUP, the first thing y ou need to d o is choose 
a development case : the process you are g oing to use in the pr oject. Development cases ca n vary 
widely, so don't assume that y our development case will l ook that much like any other developmen t 
case. Ch oosing a development case needs someone early on who is very familiar with RUP: s omeone 
who can tailor RUP for a parti cular pr oject's needs. A lternatively, there is a growing body of 
packaged development cases to start from. 
Whatever  the development case, RUP is essen tially an iterative process. A waterfall style isn' t 
compatible w ith the ph ilosophy of RUP, although sadly it's not uncomm on to run into pr ojects that 
use a waterfa ll-style process and dress  it up in RUP's cl othes. 
All RUP pr ojects sh ould follow four phases. 
1. Incepti on makes an initial evalua tion of a project. Typically  in inception, y ou decide whether 
to commit enough funds to do an elabora tion phase. 
2. Elaborati on identifies the primary use cases of the pr oject and builds software in  iterations 
in order to shake out the architecture of the s ystem. At the end of elabora tion, you should 
have a g ood sense of the requirements and a skeletal working system that acts as the see d 
of development. In particular, you should have found and res olved the ma jor risks t o the 
project. 
3. Construction  continues the bu ilding process, developing enough functionality t o release. 
4. Transition  includes vari ous late-stage activi ties that y ou don't do iteratively. These may 
include depl oyment into the data center, user training, and the  like. 
There's a fair amount of fuzziness between the phases, especially between elaborati on and 
construction. For some, the shift to c onstruction is the point at which y ou can m ove into a predictive 
planning mode. For others, it merely indicates the point at which you have a broad vision of 
requirements and an archite cture that you think is g oing to last  the rest of the pr oject. 
Some times, RUP is referred to as  the Unified Process (UP). This is usually d one by organizati ons that 
wish t o use the terminology and overall style of RUP without using  the licensed products of Rationa l 
Software. Y ou can think of RUP as Ra tional's product offering based on the UP, or y ou can think of 
RUP and UP as the same t hing. Either way, you'll find people who agree with you. 
Fitting a Process to a Proj ect 
Software pr ojects differ greatly fr om one an other. The way y ou go ab out software developmen t 
depends on many factors: the kind of system you're building, the te chnology you're using, the size 
and distribu tion of the team,  the nature of the risks, the consequences of failure, the working style s 



31/118 of the team, and the culture of the organiza tion. As a resu lt, you should never expect there to be a 
one-size-fits-all pr ocess that will work for all pr ojects. 
Consequently, you always have to adapt a process to f it your par ticular envir onment. One of  the 
first things y ou need to do is l ook at your pr oject and consider which processes seem close to a fit. 
This sh ould give you a short list of processes t o consider. 
You sh ould then c onsider what adapta tions you need t o make to fit them to y our project. You have 
to be somewhat care ful with this. Many proce sses are diffic ult to fully appreciate until you've worked 
with them. In these cases, it's often worth using the pr ocess out of the box for a couple of iterat ions 
until you learn how it works. Then you can star t modifying the process. If from  the beginning you 
are more fami liar with how a process works, you can modify  it from the begi nning. Remember that 
it's usually easier t o start with t oo little and ad d things than it is to start with t oo much and take 
things away. 
Patte rns 
The UML tells y ou how to express an object-oriented design. Patterns l ook, instead, at  the 
results of the process: example designs. 
Many people have c ommented that pr ojects have problems because  the people involved 
were not aware of designs that are well known to those w ith more experience. Pattern s 
describe common ways of d oing things and are co llected by people wh o spot repea ting 
themes in designs. These people take each theme and describe it s o that other people can 
read the pattern and see how to apply it. 
Let's l ook at an example. Say that you have some objects running in a process on your 
desktop and that they need to c ommunicate with other objects ru nning in an other 
process. Perhaps this process is also on your desktop; perhaps it resides elsewhere. You 
don't want the objects  in your system to have to worry ab out finding other objects on the 
network or execu ting remote procedure ca lls. 
What you can do is create a pr oxy object w ithin your local process for the remote object. 
The proxy has the same interface as the remote object. Your local objects talk t o the 
proxy, using  the usual in-process message sends. The pr oxy then is responsible for 
passing any messages on t o the real object, wherever it might reside. 
Proxies are a c ommon te chnique used in networks and elsewhere. People have a l ot of 
experience using pr oxies, knowing how they can be used, what advantages they ca n 
bring, their limita tions, and how t o implement  them. Methods b ooks like this one don' t 
discuss this knowledge; all they discuss is how  you can diagram a pr oxy, although use ful, 
is not as useful as discussing the experience in volving proxies. 
In the early 1990s, some people began t o capture this experience. They formed a 
community interested in writing patterns. These people sponsor c onferences and hav e 
produced several b ooks. 
The m ost famous patterns b ook to emerge fr om this group is [Gang of Four], whic h 
discusses 23 design patterns in deta il. If you want t o know about proxies, this b ook 
spends ten pages on the subject, giving details about how the objects work together, the 
benefits and limita tions of the pattern, c ommon varia tions, and implementati on tips. 
A pattern i s much more than a model. A patte rn must also include the reason why it is th e 
way it is. It is often said that a pattern is a s olution to a problem. The pattern mus t 
identify the problem clearly, explain why it s olves the problem, and also explain  the 
circumstances under which the pattern works and doesn't work. 
Patterns are important because they are  the next stage beyond understanding the basics 
of a language or a modeling te chnique. Patter ns give you a series of solutions and als o 



32/118 show you what makes a go od model and how you go ab out constructing a model. Pattern s 
teach by example. 
When I started out, I wondered why I had to invent things from scratch. Why didn't I have 
handb ooks to show me how to do c ommon things? The patterns com munity is trying t o 
build these handb ooks. 
There are now many pa tterns b ooks out there, and they vary greatly in qua lity. My 
favorites are [Gang of Four], [POSA1], [POSA2], [Core J 2EE Patterns], [P ont], and w ith 
suitable immodesty [Fowler, AP] and [Fowler, P  of EAA]. You can also take a l ook at th e 
patterns home page: http://www.hillside.net/patter ns. 
 
However c onfident you are with your pr ocess when you begin, it's essential t o learn as you go along. 
Indeed, one of the great benefits of iterative development is  that it supports frequent proces s 
improvement. 
At the end of each iteration, conduct an iteration retrospective , whereby the team assemble s to 
consider how things went and how  they can be  improved. A couple of h ours is plenty if you r 
iterations are short. A g ood way to d o this is t o make a list with three categories: 
1. Keep:  things that worked well that y ou want t o ensure y ou continue to d o 
2. Problems:  areas that aren't working wel l 
3. Try: changes t o your process to improve i t 
You can start each itera tion retrospec tive after the first by reviewing  the items fr om the previ ous 
session and seeing how t hings have changed. Don't forget the list of t hings to keep; it's important t o 
keep track of  things  that are wor king. If you don't d o that, y ou can l ose a sense of perspective  on 
the pr oject and poten tially stop pa ying attenti on to winning practices. 
At the end of a pr oject or at a ma jor release, you may want t o consider a more forma l project 
retrospective  that will last a couple of days; see http://www.retrospectives.co m/ and [Kerth ] 
for more details. One of my biggest irr itations is how organiza tions consistently fail to learn from 
their own experience and end up ma king expe nsive mistakes time and time again. 
Fitting the UML into a Process 
When they l ook at graphical modeling languages, people usually think of them  in the c ontext of a 
waterfall process. A waterfall process usually has documents that act as the handoffs between 
analysis, design, and coding phases. Graphical models can often form a ma jor part of these 
documents. Indeed, many of the structured methods from the 1970s and 1980s talk a l ot about 
analysis and design models like this. 
Whether or not you use a waterfall approach, you st ill do the activi ties of analysis, design, cod ing, 
and testing. You can run an iterative pr oject w ith 1-week itera tions, with each week a miniwaterfa ll. 
Using  the UML doesn't necessarily imply developing documents or feeding a complex CASE t ool. 
Many people draw UML diagrams on whiteboards only during a meeting to help c ommunicate their 
ideas. 
Requirements Analysis 
The activity of requirements analysis involves trying to figure out what the users and cust omers of a 
software effort want the system to do. A num ber of UML techniques can come in handy here: 
• Use cases, which describe how people interact with the system. 
• A class diagram drawn fr om the conceptual perspective, which can be a g ood way of building 
up a rigor ous vocabulary of the domain. 



33/118 • An activity diagram, which can show the work f low of the organization, showing how s oftware 
and human activi ties interact. An activity diagram can show the c ontext for use cases and 
also the details of how a complicated use case works. 
• A state diagram, which can be useful if a concept has an interes ting life cycle, w ith vari ous 
states and events that change that state. 
When working  in requirements analysis, rem ember that the m ost important  thing is com munication 
with your users and cust omers. Usually,  they are not software people and wi ll be unfamiliar wi th the 
UML or any other technique. Even so, I've had  success using these techniques with nontechnica l 
people. To d o this, remember that it's importa nt to keep the notati on to a minimum. Don't introduc e 
anything that specific to the software impleme ntation. 
Be prepared to break the rules of  the UML at any time if it helps y ou communicate better. The 
biggest risk w ith using  the UML in analysis is that you draw diagrams  that the domain experts don' t 
fully understand. A diagram that isn't underst ood by the people who know the domain is worse  than 
useless; all  it does is breed a false sense of confidence for the development team. 
Design 
When y ou are doing design, y ou can get more  technical with your diagrams. Y ou can use more 
notati on and be more precise about y our nota tion. Some useful techniques are 
• Class diagrams from a s oftware perspective. These show the classes in the software and how 
they interrelate. 
• Sequence diagrams for c ommon scenarios. A valuable approach is to pick the most importan t 
and interesting scenarios fr om the use cases and use CRC cards or sequence diagrams t o 
figure out what happens in the s oftware. 
• Package diagrams to show the large-scale organizati on of the s oftware. 
• State diagrams for classes with complex life his tories. 
• Deployment diagrams to show the physical layout of the s oftware. 
Many of these same techniques can be used t o document s oftware once it's been wr itten. Thi s may 
help people find their way around the software if they have to work on it and are not familiar w ith 
the code. 
With a waterfall life cycle, you w ould do these diagrams and activities as part of the phases. Th e 
end-of-phase documents usually include  the appropriate UML diagrams for that a ctivity. A wate rfall 
style usually implies that the UML is used as a blueprint. 
In an iterative style, the UML diagrams can be  used in either a blueprint or a sketch style. Wit h a 
blueprint, the analysis diagrams will usua lly be built in  the iteration prior t o the one that build s the 
functionality. Each itera tion doesn't start fr om scratch; rather,  it modifies the existing body of 
documents, high lighting the changes in the new iteration. 
Blueprint designs are usua lly done early  in the iteration and may be d one in pieces for differen t bits 
of func tionality that are targeted for the itera tion. Again, itera tion implies making changes to a n 
existing model rather than bu ilding a new model each time. 
Using  the UML in sketch mode implies a more fluid process. One approach is t o spend a couple  of 
days at the beginning of an itera tion, sketc hing out the design for that iteration. You can also d o 
short design sessions at any p oint during the iteration, setting up a quick meeting for half an hour 
whenever a developer starts to tackle a n ontrivial function. 
With a blueprint, you expect the code implementation to fo llow the diagrams. A change from th e 
blueprint is a deviation  that needs review from  the designers who did the blueprint. A sketch i s 
usually treated more as a first cut at the design; if, during coding, people find that the sketch i sn't 
exactly right, they sh ould feel free to change the design. The implementors have t o use their 
judgment as to whether the change needs a wider discussion t o understand the f ull ramifications. 



34/118 One of my concerns with blueprints is my own observa tion that it's very hard to get them right , 
even for a g ood designer. I often find that my own designs d o not survive c ontact with coding intact. 
I still find UML sketches useful, but I don't find that they can be treated as abs olutes. 
In both modes, it makes sense t o explore a  number of design alternatives. It's usually best t o 
explore alternatives in sketch mode s o that you can quickly generate and change the alternati ves. 
Once y ou pick a design t o run with, you can either use that sketch or detail it into a blueprint. 
Documentation 
Once y ou have bu ilt the s oftware, you can use  the UML t o help d ocument what y ou have done. For 
this, I find UML diagrams useful for getting an overall understanding of a system. In d oing this, 
however, I sh ould stress that I do not believe  in produ cing detailed diagrams of the wh ole system. 
To qu ote Ward Cunningham [C unningham]: 
Carefully selected and we ll-written mem os can easily sub stitute for tradi tional 
comprehensive design d ocumentation. The latter rarely s hines except  in isolated 
spots. Elevate those sp ots . . . and forget abou t the rest. (p. 384)  
I believe that deta iled documentation should be generated fr om the code—like, for  instance, 
JavaDoc. Y ou should write addi tional documenta tion to hig hlight important concepts. Think of these 
as comprising a first step for the reader befor e he or she goes int o the code-based details. I like t o 
structure these as prose documents, short enough to read over a cup of coffee, using UML dia grams 
to help  illustrate the discussion. I prefer the diagrams as sketches that  highlight the m ost importan t 
parts of the system. Obviously, the writer of the document needs to decide what is important and 
what isn't, but the wr iter is much better equipped than the reader to d o that. 
A package diagram makes a g ood logical road map of the system. This diagram helps me 
understand the logical pieces of the system and see the dependencies and keep them under control. 
A deployment diagram (se e Chapter 8 ), which shows the high-level physical picture, may also prove 
useful at this stage. 
Within each package, I  like to see a class diagram. I don't show every opera tion on every class. I 
show only the important features that help me  understand what is in there. This class diagram act s 
as a graphical table of contents. 
The class diagram sh ould be supported by a handful of  interacti on diagrams that show the m ost 
important interactions in  the system. Again, selectivity is important here; remember that, in th is 
kind of d ocument, comprehensiveness is the enemy of comprehensibility. 
If a class has complex life-cycle behavior, I draw a state ma chine diagram (see Chapter 10 ) to 
describe it. I do this only if the behavior is sufficie ntly complex, which I find doesn't happen often. 
I'll often include s ome important code, written in a literate program style. If a particularly complex 
algorithm is  involved, I'll c onsider using an activ ity diagram (se e Chapter 11) but only if it give s me 
more understanding than the code alone. 
If I find concepts  that are coming up repeatedly, I use patterns (page 27) t o capture the basic ideas. 
One of the m ost important t hings to d ocument is the design alternatives you didn't take and why 
you didn't d o them. That's often the m ost forg otten but most useful piece of external d ocumenta tion 
you can provide. 
Understand ing Legacy Code 
The UML can help you figure out a gnarly bunch  of unfami liar code  in a couple of ways. Bu ilding a 
sketch of key facts can act as a graphical note-taking mechanism that helps you capture impo rtant 
informa tion as you learn about it. Sketches of key classes in a package and their key interacti ons 
can help clarify what's going on. 



35/118 With modern t ools, you can generate deta iled diagrams for key parts of a system. Don't use  these 
tools to generate big paper reports; instead, use them to drill int o key areas as you are exploring 
the code  itself. A particularly  nice capability is that of generating a sequence diagram t o see ho w 
multiple objects co llaborate  in handling a complex method. 
 
Choosing a Development Process 
I'm strongly in favor of iterative development processes. As I've said in this b ook before: You s hould 
use iterative development only on projects that you want to succeed. 
Perhaps that's a bit glib, but as I get older, I get more aggressive ab out using iterative 
development. D one well, it is an essential tec hnique, one you can use t o expose risk early and  to 
obtain be tter control over development. It is not the same as having n o management, althoug h to 
be fair, I sh ould point out that some have used  it that way. It does need to be well planned. But it is 
a solid approach, and every OO development b ook encourages using  it—for g ood reason. 
You sh ould not be surprised to hear that as on e the authors of the Manifesto for Ag ile Software 
Development, I'm very much a fan of ag ile approaches. I've als o had a lot of p ositive experiences 
with Extreme Programming, and certa inly you  should consider its practices very seriously. 
 
Where to Find Out More 
Books on software pr ocess have always been common, and the rise of agile s oftware developmen t 
has led t o many new b ooks. Overa ll, my favorite b ook on process in general is [McC onnell]. He give s 
a broad and practical coverage of many of the issues involved in s oftware development and a long 
list of useful pra ctices. 
From the agile com munity, [C ockburn, agile] and [Highsmith] provide a g ood overview. For a lot of 
good advice ab out applying the UML in an agile way, see [Ambler]. 
One of the m ost popular agile methods is Extreme Programming (XP), which y ou can delve into via 
such Web sites a s http://xprogra mming.com  and http://www.extremeprogra mming.org . XP 
has spawned many b ooks, which is why I now refer t o it as the formerly lightweight methodology. 
The usual starting point is [Beck]. 
Although it's wri tten for XP, [Beck and Fowler] gives more details on planning an  iterative project. 
Much of this is also covered by the other XP books, but if you're interested only in the planning 
aspect, this w ould be a g ood choice. 
For more  informa tion on the Rational Unified Process, my favor ite introdu ction is [Kruchten]. 
Chapter 3. Class Diagrams: The Essentials 
If someone were t o come up to you in a dark a lley and say, "Psst, wanna see a UML diagram?"  that 
diagram would probably be a class diagram. The ma jority of UML diagrams I see are class diagrams. 
The class diagram is not only widely used but also subject t o the greatest range of modelin g 
concepts. A lthough the basic elements are needed by everyone,  the advanced concepts are used 
less often. Therefore, I've broken my discussion of class diagrams int o two parts: the essentials (thi s 
chapter) and  the advanced ( Chapter  5). 



36/118 A class diagram  describes the types of object s in the system and the various kinds of static 
relationships that exist among  them. Class dia grams also show the proper ties and opera tions of a 
class and the c onstraints that apply to the way  objects are connected. The UML uses  the term 
feature  as a general term that covers proper ties and operati ons of a class. 
Figure 3.1  shows a simple class model  that would n ot surprise anyone wh o has worked w ith order 
processing. The boxes in  the diagram are classes, which are divided into three compartments: the 
name of the class (in bold), its attributes, and its operati ons. Figure 3 .1 also shows two kinds of 
relationships between classes: associa tions and genera lizations. 
Figure 3.1. A simple class diagram 
 
Properties 
Properties  represent stru ctural features of a class. As a first appr oximation, you can think of 
properties as corresponding to fields in a class. The rea lity is rather involved, as we shall see, bu t 
that's a reasonable place to start. 
Properties are a single concept, but they appear in tw o quite distinct notations: attributes and 
associa tions. Although they l ook quite different  on a diagram, they are really the same thing. 
Attributes 
The attribute  notation describes a property a s a line of text within  the class box  itself. The full form 
of an attribute is: 
 



37/118 visibility name: type multiplicity = default {property-string} 
An example of this is: 
 
- name: String [1] = "Untitled" {readOnly} 
Only the name is necessary. 
• This visibility  marker  indicates whether the a ttribute is public (+) or private (-); I'l l 
discuss other visibi lities on page 83. 
• The name of the a ttribute—how  the class refers to the attribute—roughly corresponds to th e 
name of a field  in a programming language. 
• The type of the a ttribute indicates a restric tion on what kind of object may be placed in the 
attribute. Y ou can think of  this as the type of a field in a programming language. 
• I'll explain multiplicity  on page 38. 
• The default value  is the value for a newly c reated object if the a ttribute isn't specified 
during crea tion. 
• The {property-string}  allows you t o indicate additional prope rties for the attribute.  In the 
example, I used {readOnly}  to indicate that c lients may not modify the property. If this is 
missing, you can usua lly assume that the attribute is modifiable. I' ll describe other property 
strings as we go. 
Associations 
The other way t o notate a property is as an association. Much of the same informati on that y ou can 
show on an attribute appears on an associa tion. Figures 3 .2 and 3.3 show the same propertie s 
represented in the two different notations. 
Figure 3.2. Showing properties of an order as attributes 
 
Figure 3.3. Showing properties of an order as associations 
 
An associati on is a s olid line between two classes, directed from the source class t o the targe t 
class. The name of the property goes at the target end of the ass ociation, together w ith its 
multiplicity. The target end of the ass ociation links to the class that is the type of the property. 



38/118 Although m ost of the same information appear s in both notati ons, some items are different. I n 
particular, associations can show mu ltiplicities at b oth ends of the line. 
With two notations for the same t hing, the obvious que stion is,  Why should y ou use one or  the 
other? In general, I tend to use attributes for small things, such as dates or B ooleans—in general, 
value types (page 73)—and associa tions for more significant classes, such as cust omers and orders. 
I also tend to prefer t o use class boxes for cla sses that are significant for the diagram, which leads 
to using associa tions, and attributes for things  less important for that diagram. The ch oice is much 
more ab out emphasis than about any underlying meaning. 
 
When to Use Class Diagrams 
Class diagrams are the backbone of the UML, so you will find yourself using them all the time. This 
chapter covers the basic concepts; Chapter  5 discusses many of the advanced concepts. 
The trouble w ith class diagrams is that they ar e so rich,  they can be overwhel ming to use. Her e are 
a few tips. 
• Don't try t o use all the notati ons available to you. Start with the simple stuff in this chapter: 
classes, associa tions, attributes, generalization, and constra ints. Introduce other notati ons 
from Chapter  5 only when you need them. 
• I've found conceptual class diagrams very usef ul in exploring the language of a business. For 
this to work, y ou have to work hard on keepin g software out of the discussi on and keeping 
the notati on very simple. 
• Don't draw models for everything; instead, concentrate on  the key areas. It is be tter to have 
a few diagrams that you use and keep up to date than t o have many forg otten, obsolet e 
models. 
The biggest danger with class diagrams is that  you can f ocus ex clusively on structure and ignor e 
behavior. Therefore, when drawing class diagrams to understand software, always d o them in 
conjunction with some form of behavioral tech nique. If you're going we ll, you'll find yourself 
swapping between the tec hniques freque ntly. 
 
Where to Find Out More 
All the general UML b ooks I men tioned i n Chapter 1  talk about class diagrams in more detail. 
Dependency management is a cri tical feature of larger pr ojects. The best b ook on this topic i s 
[Martin]. 
 
Multiplicit y 
The multiplicity  of a property is an indica tion of how many objects may fill the property. The most 
comm on multiplicities y ou will see are 
• 1 (An order must have exactly one cust omer.) 
• 0..1 (A corporate customer may or may not have a single sales rep.) 
• * (A customer need not place an Order and there is n o upper limit to the  number of Orders a 
Customer may place—zero or more orders.) 
More generally, m ultiplicities are de fined with a lower bound and an upper bound, such as 2..4  for 
players of a game of canasta. The lower b ound may be any p ositive number or zero; the upper is 



39/118 any p ositive number or * (for  unlimited). If the lower and upper b ounds are  the same, you can use 
one number; hence, 1 is equivalent t o 1..1. Because  it's a common case, * is short for 0..*. 
In attributes, you come across various terms that refer t o the multiplicity. 
• Optional  implies a lower b ound of 0. 
• Mandatory  implies a lower bound of 1 or p ossibly more. 
• Single-valued  implies an upper b ound of 1. 
• Multivalued  implies an upper b ound of more  than 1: usually *. 
If I have a multivalued property, I prefer t o use a plural form for  its name. 
By defau lt, the elements in a mu ltivalued mu ltiplicity form a set, s o if you ask a customer for  its 
orders, they d o not come back  in any order. If  the ordering of the orders  in associa tion has 
meaning, y ou need to add {ordered}  to the association end. If y ou want to allow duplicates, add 
{nonunique} . (If y ou want to explicitly show the default, you can us e {unordered}  and {unique}.) 
You may also see co llection-oriented names, such a s {bag}  for unordered, non unique. 
UML 1 allowed disc ontinuous mu ltiplicities, suc h as 2, 4 (meaning 2 or 4, as in cars  in the day s 
before minivans). Disc ontinuous mu ltiplicities weren't very common and UML 2 rem oved them. 
The default multiplicity of an attribute is [1]. Although this is true in the meta-model, y ou can't 
assume that an attribute in a diagram that's missing a multiplicity has a value of [1], as the diagram 
may be suppressing  the multip licity informa tion. As a resu lt, I prefer to explicitly state a [1] 
multiplicity if  it's important. 
 
Programming Interpretatio n of Properties 
As with anyt hing else in the UML,  there's no one way to interpret properties in code. The mos t 
comm on software representati on is that of a field or property of your programming language.  So the 
Order Line class fr om Figure 3 .1 would correspond to something like the fo llowing  in Java: 
 
public class OrderLine... 
  private int quantity; 
  private Money price; 
  private Order order; 
  private Product product 
In a language like C#, which has properties, i t would correspond to: 
 
public class OrderLine ... 
  public int Quantity; 
  public Money Price; 
  public Order Order; 
  public Product Product; 
Note that an attribute typically corresp onds to public properties in a language that support s 
properties but to private fields  in a language that does not. In a language w ithout properties, you 
may see the fields exposed  through accessor (get ting and setting) methods. A read- only attribute 
will have no setting method (with fields) or set ac tion (for properties). N ote that if you don't gi ve a 
name for a property, it's common t o use the name of  the target class. 
Using private fields is a very implementation-f ocused interpretati on of the diagram. A more 
interface-oriented interpretati on might  instead concentrate on the getting methods rather  than the 



40/118 underlying data. In  this case, we might see th e Order Line's attributes corresponding to the 
following methods: 
 
public class OrderLine... 
  private int quantity; 
  private Product product; 
  public int getQuantity() { 
    return quantity; 
  } 
  public void setQuantity(int quantity) { 
    this.quantity = quantity; 
  } 
  public Money getPrice() { 
    return product.getPrice().multiply(quantity); 
  } 
In this case, there is no data field for price;  instead, it's a computed value. But as far as c lients of 
the Order Line class are concerned,  it looks the same as a field. C lients can't tell what is a field and 
what is computed. This informa tion hiding is the essence of encapsulation. 
If an attribute is multivalued, this implies  that the data concerned is a collection. So an Order class 
would refer to a c ollection of Order Lines. Because this multiplicity is ordered,  that collection mus t 
be ordered, (such as a List in Java or an IList in .NET). If the c ollection is unordered, it sh ould, 
strictly, have no meaningful order and thus be  implemented with a set, but m ost people impl ement 
unordered attributes as lists as we ll. Some people use arrays, but  the UML implies an unlimited 
upper b ound, so I almost always use a co llection for data structure. 
Multivalued properties yield a different kind of interface to single-valued properties (in Java): 
 
class Order { 
  private Set lineItems = new HashSet(); 
  public Set getLineItems() { 
    return Collections.unmodifiableSet(lineItems); 
  } 
  public void addLineItem (OrderItem arg) { 
    lineItems.add (arg); 
  } 
  public void removeLineItem (OrderItem arg) { 
    lineItems.remove(arg); 
  } 
In most cases, you don't assign to a  multivalued property; instead, y ou update with add and remove 
methods. In order to control its Line Items property, the order must c ontrol member ship of that 
collection; as a result, it sh ouldn't pass out the naked c ollection. In  this case, I used a prote ction 
proxy to pr ovide a read- only wrapper t o the collection. You can also provide a n onupdatable iterator 
or make a copy. It's okay for clients to modify  the member objects, but the clients sh ouldn't directly 
change the c ollection  itself. 
Because m ultivalued attributes imply c ollections, you alm ost never see co llection classes on a class 
diagram. Y ou would show them only in very low level implementati on diagrams of co llections 
themselves. 
You sh ould be very afraid of classes that are n othing but a collecti on of fields and  their accesso rs. 
Object-oriented design is ab out providing objects that are able to d o rich behavior, so they sh ouldn't 
be simply providing data to other objects. If y ou are making repeated calls for data by using 
accessors, that's a sign that some behavior should be moved t o the object that has the data. 
These examples als o reinforce the fact  that there is n o hard-and-fast correspondence between the 
UML and code, yet  there is a similarity. Within a pr oject team, team conven tions will lead to a c loser 
correspondence. 



41/118 Whether a property is implemented as a field or as a calculated value,  it represents some thing an 
object can always provide. You sh ouldn't use a property t o model a transient rela tionship, such as 
an object that is passed as a parameter during a method call and used only within the confines of 
that interaction. 
 
Bidirectional Associations 
The ass ociations we've l ooked at so far are called unidirectional associa tions. Another c ommon kind 
of ass ociation is a bidirectional association, su ch as Figure 3.4 . 
Figure 3.4. A bidirectional association 
 
A bidirectional associa tion is a pair of propertie s that are linked together as inverses. The Car class 
has property owner:Person[1] , and the Person class has a property cars:Car[*] . (Note how I 
named the cars property  in the plural form of the property's type, a c ommon but non-normat ive 
convention.) 
The inverse link between them imp lies that if you fo llow both proper ties, you should get back t o a 
set that contains y our starting p oint. For example, if I begin with a par ticular MG Midget, find its 
owner, and then l ook at its owner's cars, that set sh ould contain the Midget  that I started from. 
As an a lternative t o labeling an ass ociation by a property, many people, particularly if they hav e a 
data-modeling background,  like to label an associati on by using a verb phrase ( Figure 3.5 ) so that 
the relati onship can be used  in a sentence. Thi s is legal and you can add an arrow to the ass ociation 
to avoid ambig uity. Most object modelers prefer t o use a property name, as that corresponds be tter 
to responsibil ities and operations. 
Figure 3.5. Using a verb phrase to name an association 
 
Some people name every ass ociation in some way. I ch oose to name an ass ociation only when doing 
so improves understanding. I've seen t oo many associa tions with such names as "has" or "is related 
to." 
In Figure 3.4 , the bidirec tional nature of the as sociation is made obvious by th e navigability 
arrows at both ends of the associa tion. Figure 3.5 has no arrows; the UML a llows y ou to use this 
form either to indicate a bidirec tional ass ociation or when you aren't showing navigability. My 
preference is to use the double-headed arrow of Figure 3.4  when you want to make it clear that you 
have a bidirectional associa tion. 
Implementing a bidire ctional ass ociation in a programming language is often a little tricky because 
you have to be sure  that both prope rties are kept synchronized. Using C#, I use code along  these 
lines t o implement a bidirectional associa tion: 
 
class Car... 



42/118   public Person Owner { 
    get {return _owner;} 
    set { 
      if (_owner != null) _owner.friendCars().Remove(this); 
      _owner = value; 
      if (_owner != null) _owner.friendCars().Add(this); 
    } 
} 
private Person _owner; 
... 
class Person ... 
  public IList Cars { 
    get {return ArrayList.ReadOnly(_cars);} 
  } 
  public void AddCar(Car arg) { 
    arg.Owner = this; 
  } 
  private IList _cars = new ArrayList(); 
  internal IList friendCars() { 
    //should only be used by Car.Owner 
    return _cars; 
  } 
.... 
The primary thing is t o let one side of the ass ociation—a single-valued side, if p ossible—control  the 
relationship. For this to work, the slave end (Person) needs t o leak the encapsula tion of its data t o 
the master end. This adds t o the slave class a n awkward method, which sh ouldn't really be th ere, 
unless the language has fine-grained access control. I've used the naming conven tion of "friend " 
here as a nod to C++, where  the master's setter would indeed be a friend. Like much property  code, 
this is pretty b oilerplate stuff, which is why many people prefer t o use some form of code genera tion 
to produce it. 
In conceptual models, navigab ility isn't an important issue, so I don't show any navigability arrows 
on conceptual models. 
Operations 
Operations  are the ac tions that a class knows to carry out. Opera tions most obviously correspond 
to the methods on a class. Normally, you don't  show those operations that simply manipulate 
properties, because they can usually be inferred. 
The full UML syntax for operati ons is: 
 
visibility name (parameter-list) : return-type {property-string} 
• This visibility  marker is public (+) or private (-); others on page 83. 
• The name is a string. 
• The parameter-list  is the list of parameters for the operation. 
• The return-type  is the type of the returned value, if  there is one. 
• The property-string  indicates property values that apply t o the given opera tion. 
The parameters in the parameter list are notated in a similar way to attributes. The form is: 
 
direction name: type = default value 
• The name, type, and default value  are the same as for attributes. 
• The direction  indicates whether the paramet er is input ( in), output (out) or b oth (inout ). 
If no direc tion is shown, it's assumed to b e in. 



43/118 An example operati on on acc ount might be: 
 
+ balanceOn (date: Date) : Money 
With conceptual models, y ou shouldn't use opera tions to specify the interface of a class. Instead, 
use them t o indicate the principal responsibilities of that class, perhaps using a couple of words 
summarizing a CRC responsib ility (page 65). 
I often find it useful to distinguish between opera tions that change  the state of the system and thos e 
that don't. UML defines a query  as an operati on that gets a value from a class without changing the 
system state—in other words, with out side effects.Y ou can mark such an operati on with the propert y 
string {query} . I refer to opera tions that d o change state a s modifiers , also called c ommands . 
Strictly, the difference between query and modifiers is whether they change the observable state 
[Meyer]. The observable state is what can be perceived from  the outside. An opera tion that updates 
a cache w ould alter the internal state but woul d have no effect that's observable fr om the outside. 
I find it helpful t o highlight queries, as you can change the order of execution of queries and no t 
change the system behavior. A common conven tion is to try to wr ite operati ons so that modifi ers do 
not return a value; that way, you can rely on the fact that operations that return a value ar e 
queries. [Meyer] refers t o this as the C ommand-Query separati on principle. It's sometimes awkward 
to do this all the  time, but you sh ould do it as much as y ou can. 
Other terms you sometimes see are getting methods and setting methods. A getting method  
returns a value fr om a field (and does not hing else). A setting method  puts a value into a fiel d 
(and does nothing else). From the outside, a client should not be able t o tell whether a query i s a 
getting method or a modifier is a set ting method. Knowledge of getting and setting methods is 
entirely internal t o the class. 
Another dis tinction is between opera tion and method. A n operation  is something  that is invoked on 
an object—the procedure declarati on—whereas a method  is the body of a procedure. The two are 
different when you have polymorphism. If you  have a supertype with three subtypes, each of which 
overrides the supertype's getPrice  operation, you have one opera tion and four methods tha t 
implement it. 
People usually use the term s operati on and method interchangeably, but  there are  times when it is 
useful to be precise about the difference. 
Generalization 
A typical example of generalization  involves the personal and corporate customers of a business. 
They have differences but also many similarities. The sim ilarities can be placed in a genera l 
Customer class (the supertype), w ith Personal Customer and Corporate Customer as subtypes. 
This phenomenon is also subject t o various  interpretations at the vari ous perspectives of mode ling. 
Conceptua lly, we can say  that Corporate Customer is a subtype of Customer if all instances of 
Corporate Customer are also, by definition, in stances of Customer. A Corporate Customer is then a 
special kind of Customer. The key idea is that everyt hing we say about a Customer—associati ons, 
attributes, opera tions—is true als o for a Corporate Customer. 
With a software perspective, the obvious  interpretati on is inheritance: The Corporate Customer is a 
subclass of Customer.  In mainstream OO languages, the subclass inherits all the features of the 
superclass and may override any superclass methods. 
An important principle of using inheritance effec tively is substitutability . I should be able t o 
subst itute a Corporate Customer wi thin any code that requires a Cust omer, and everyt hing shoul d 
work fine. Essentially,  this means that if I wr ite code assuming I have a Customer, I can freely use 
any subtype of Customer. The Corporate Customer may resp ond to certain commands differe ntly 



44/118 from an other Customer, using polymorphism, but the caller should not need to worry ab out the 
difference. (For more on  this, see the Lisk ov Substitution Principle (LSP) in [Martin].) 
Although inheritance is a powerful mechanism, it brings in a lot of baggage  that isn't always needed 
to achieve sub stitutability. A g ood example of this was in  the early days of Java, when many people 
didn't like the implementation of the built-in V ector class and wanted to replace it with something 
lighter. However,  the only way  they c ould produce a class that was subs titutable for Vector was t o 
subclass it, and that meant  inheriting a lot of  unwanted data and behavior. 
Many other mechanisms can be used to pr ovide subst itutable classes. As a resu lt, many people like 
to differen tiate between subtyping, or interface inheritance, and subclassing, or implementa tion 
inheritance. A class is a subtype  if it is substitutable for  its supertype, whether or not it uses 
inheritance. Subclassing  is used as a synonym for regular inheritance. 
Many other mechanisms are ava ilable that allow you t o have subtyping with out subclassing. 
Examples are implemen ting an interface (page 69) and many of the standard design patterns [Gan g 
of Four]. 
Notes and Comments 
Notes are c omments in  the diagrams. Notes can stand on their own, or they can be linked w ith a 
dashed line t o the elements they are c ommenting (Figure 3.6 ). They can appear in any kind of 
diagram. 
Figure 3.6. A note is used as a comment on one or more diagram elements 
 
The dashed line can sometimes be awkward b ecause you can't p osition exactly where this line ends. 
So a c ommon convention is to put a very smal l open circle at  the end of the line. S ometimes, it's 
useful to have an in-line c omment on a diagr am element. You can do this by prefixing  the text with 
two dashes: --. 
 
Dependenc y 
A dependency  exists between two elements if changes t o the de finition of one element (the 
supplier ) may cause changes to the other (the client ). With classes, dependencies exist for variou s 
reasons: One class sends a message to an other; one class has an other as part of its data; one class 
mentions an other as a parameter to an operation. If a class changes its  interface, any messag e sent 
to that class may n o longer be va lid. 
As computer systems grow, y ou have to worr y more and more ab out contr olling dependencies. If 
dependencies get out of control, each change to a system has a wide ripple effect as more an d more 
things have t o change. The bigger the ripple, the harder it is to change anything. 
The UML a llows y ou to depict dependencies between all sorts of elements. You use dependencies 
whenever y ou want to show how changes in one element might alter other elements. 
Figure 3.7  shows some dependencies that you might find in a multilayered application. The Benefits 
Window class—a user interface, or presentati on class—is dependent on the Employee class: a 



45/118 domain object  that captures the essen tial behavior of the system—in  this case, business rules. This 
means that if  the empl oyee class changes  its interface,  the Benef its Window may have to change. 
Figure 3.7. Example dependencies 
 
The important thing here is  that the dependen cy is in only one direc tion and goes fr om the 
presenta tion class t o the domain class. This way, we know that we can freely alter the Benefits 
Window with out those changes having any effect on the Employee or other domain objects. I'v e 
found that a strict separati on of presenta tion and domain logic, with the presentation depending on 
the domain but not vice versa, has been a valuable rule for me t o follow. 
A second notable  thing from  this diagram is that there is no direct dependency fr om the Benefi ts 
Window to the two Data Gateway classes. If these classes change, the Employee class may have t o 
change. But if the change is only to the implementa tion of the Employee class, n ot its interface, th e 
change stops  there. 
The UML has many varieties of dependency, each w ith particular semantics and keywords. The basic 
dependency that I've outlined here is  the one I find the most useful, and I usually use it w ithout 
keywords. To add more detail, you can add an appropriate keyword ( Table 3.1 ). 
The basic dependency is not a transitive rela tionship. An example of a transitive  relationship is th e 
"larger beard" rela tionship. If Jim has a larger beard than Grady, and Grady has a larger beard  than 
Ivar, we can deduce that Jim has a larger beard than Ivar. S ome kind of dependencies, such a s 
subst itute, are transitive, but in m ost cases there is a significant difference between direct an d 
indirect dependencies, as there is i n Figure 3.7 . 
Many UML relati onships imply a dependency. The navigable association from Order to Custome r in 
Figure 3.1  means that Order is dependent on Customer. A subclass is dependent on its superclass 
but not vice versa. 
Table 3.1. Selected Dependency Keywords 
Keyword Meaning 
«call»  The source calls an operation in the target. 
«create»  The source creates  instances of the target. 
«derive»  The source is derived from  the target. 
«instantiate»  The source is an  instance of  the target. (Note that if the source is a class, the class 
itself is an instance of the class class;  that is, the target class is a metaclass). 
«permit»  The target allows the source to access the target's private features. 
«realize»  The source is an implementa tion of a specificat ion or interface defined by  the targe t 
(page 69). 
«refine»  Refinement indicates a rela tionship between di fferent semantic levels; for example, 
the source might be a design class and the target the corresponding analysis class. 
«substitute»  The source is substi tutable for  the target (pag e 45). 
«trace»  Used t o track such things as requirements to classes or how changes in one mode l 



46/118 Table 3.1. Selected Dependency Keywords 
Keyword Meaning 
link to changes elsewhere. 
«use»  The source requires the target for its impleme ntation. 
Your general rule should be to minimize dependencies, particularly when  they cross large areas  of a 
system. In particular, you sh ould be wary of cycles, as they can lead to a cycle of changes. I'm no t 
super strict on  this. I don't mind mutual dependencies between cl osely related classes, but I d o try 
to eliminate cycles at a broader level, pa rticularly between packages. 
Trying to show all the dependencies in a class diagram is an exercise in f utility; there are t oo many 
and they change t oo much. Be sele ctive and show dependencies only when they are dire ctly 
relevant to the particular topic  that you want t o communicate. T o understand and contro l 
dependencies, y ou are best off u sing them with package diagrams (pages 89). 
The m ost common case I use for dependencies with classes is when i llustrating a transien t 
relationship, such as when one object is passed to another as a parameter. You may see these  used 
with keywords «parameter» , «local» , and «global» . You may als o see these keywords on 
associa tions in UML 1 models, in which case they indicate transient links, not properties. These 
keywords are not part of UML 2. 
Dependencies can be determined by l ooking at  code, so t ools are ideal for d oing dependency 
analysis. Getting a t ool to reverse engineer pi ctures of dependencies is the m ost useful way t o use 
this bit of  the UML. 
Constraint Rules 
Much of what y ou are doing in drawing a class diagram is indicating constra ints. Figure 3.1  indicates 
that an Order can be placed only by a single Customer. The diagram als o implies that each Lin e 
Item is  thought of separately: Y ou say "40 brown widgets, 40 blue widgets, and 40 red widgets," n ot 
"120 things" on  the Order. Further, the diagram says that Corporate Customers have credit lim its 
but Personal Customers d o not. 
The basic constructs of ass ociation, attribute, and generalizati on do much to specify importan t 
constra ints, but they cannot indicate every c onstraint. These c onstraints st ill need to be captured; 
the class diagram is a g ood place to do that. 
The UML a llows y ou to use anything to describe constra ints. The only rule is that you put them 
inside braces ({}). Y ou can use natural language, a programming language, or the UML's forma l 
Object Constraint Language (OCL) [Warmer and Kleppe], which is based on predicate calculus. 
Using a formal nota tion avoids  the risk of mis interpretation due to an ambigu ous natural language. 
However,  it introduces  the risk of mis interpretat ion due to writers and readers n ot really 
understanding OCL. So unless y ou have readers who are c omfortable with predicate calc ulus, I'd 
suggest u sing natural language. 
Optionally, you can name a c onstraint by putting the name first, fo llowed by a col on; for exa mple, 
{disallow incest: husband and wife must not b e siblings}. 
Design by Contract 
Design by C ontract is a design tec hnique developed by Bertrand Meyer [Meyer]. The 
technique is a central feature of  the Eiffel language he developed. Design by C ontract is 
not specific t o Eiffel, however;  it is a valuable technique  that can be used w ith any 
programming language. 
At the heart of Design by Contract is the asser tion. An assertion  is a B oolean statemen t 



47/118 that sh ould never be false and,  therefore, w ill be false only because of a bug. Typically, 
asser tions are checked only during debug and are n ot checked during production 
execution. Indeed, a program should never as sume that asser tions are being checked. 
Design by C ontract uses three particular kinds of assertions: p ost-conditi ons, pre-
conditions, and invariants. Pre-conditi ons and post-condi tions apply to opera tions. A post-
condition  is a statement of what the world should l ook like after execution of an 
opera tion. For instance, if we define the opera tion "square r oot" on a number, the p ost-
condition would take the for m input = re sult * result, where result is the output and input 
is the input value. The p ost-condi tion is a useful way of saying what we do without sayin g 
how we d o it—in other words, of separating interface fr om implementa tion. 
A pre-condition  is a statement of how we expect the world to be before we execute an 
opera tion. We might de fine a pre-condi tion for the "square r oot" operation of input > =  0. 
Such a pre-condition says that it is an error t o invoke "square r oot" on a negative number 
and that the consequences of d oing so are undefined. 
On first glance,  this seems a bad idea, because we should put some check somewhere t o 
ensure that "square r oot" is invoked properly. The important que stion is wh o is 
responsible for d oing so. 
The pre-condi tion makes it explicit that the ca ller is responsible for chec king. Without this 
explicit statement of responsib ilities, we can get either t oo little checking—because bot h 
parties assume  that the other is resp onsible—o r too much—b oth parties check. T oo much 
checking is a bad  thing because it leads to a lot  of duplicate chec king code, which can 
significan tly increase the complexity of a program. Being explicit about wh o is responsibl e 
helps to reduce this complexity. The danger  that the caller forgets to check is reduced b y 
the fact  that asse rtions are usually checked during debugging and testing. 
From these defin itions of pre-conditi on and post-condi tion, we can see a strong defini tion 
of the term excepti on. An exception occurs when an opera tion is invoked with its pre-
condition satisfied yet cannot return w ith its p ost-condi tion satisfied. 
An invariant  is an asserti on about a class. For  instance, an Acc ount class may have an 
invariant that says  that balance == sum(entri es.amount()) . The invariant is "always" true 
for all instances of  the class. Here, "always" means "whenever the object is available t o 
have an operation  invoked on  it." 
In essence, this means that the invariant is added to pre-condi tions and p ost-condi tions 
associated with all public operations of the given class. The  invariant may become fals e 
during execu tion of a method, but it sh ould be restored t o true by the time any other 
object can do anyt hing to the receiver. 
Assertions can play a unique role in subclassing. One of the dangers of inher itance is tha t 
you could redefine a subclass's operati ons to be inconsistent with  the superclass's 
opera tions. Assertions reduce the chances of this. The invariants and p ost-condi tions of a 
class must apply to all subclasses. The subcla sses can ch oose to strengthen  these 
asser tions but cannot weaken them. The pre-condi tion, on the other hand, cann ot be 
strengthened but may be weakened. 
This l ooks odd at first, but it is important to allow dynamic binding. Y ou should always be 
able to treat a subclass object as if it were an instance of the superclass, per  the principl e 
of substi tutability. If a subclass strengthened  its pre-condi tion, a superclass operation 
could fa il when applied to the subclass. 
 
Chapter 4. Sequence Diagrams 



48/118 Interaction diagra ms describe how groups of  objects co llaborate  in some behavior. The UML 
defines several forms of interac tion diagram, of which  the most c ommon is  the sequence diagram. 
Typically, a sequence diagram captures the behavior of a single scenario. The diagram shows a 
number of example objects and the messages  that are passed between these objects w ithin the us e 
case. 
To begin the discussion, I'll consider a simple scenario. We have an order and are g oing to inv oke a 
command on it to calculate its price. To d o that, the order needs t o look at all  the line  items on the 
order and deter mine their prices, which are based on  the pricing rules of  the order line's products. 
Having done that for all the line items, the order then needs to compute an overall discount, which 
is based on rules tied to the customer. 
Figure 4.1  is a sequence diagram  that shows one implementa tion of that scenario. Sequenc e 
diagrams show the interac tion by showing each participant w ith a life line that runs vertically down 
the page and  the ordering of messages by reading down the page. 
Figure 4.1. A sequence diagram for centralized control 
 
One of the nice things ab out a sequence diagram is that I alm ost don't have to explain the nota tion. 
You can see  that an  instance of order sends getQuantity  and getProduct  messages t o the order 
line. You can als o see how we show  the order invoking a method on itself and how that method 
sends getDiscountInfo  to an instance of customer. 
The diagram, however, doesn't show everyt hing very well. The sequence of messages getQuantity , 
getProduct , getPricingDetails , and calculateBasePrice  needs to be done for each order line on 
the order, whil e calculateDiscounts  is invoked just once. You can't tell that from this diagram , 
although I'll introduce some more nota tion to handle that later. 
Most of the time, you can  think of the participants in an interaction diagram as objects, as ind eed 
they were in UML 1. But in UML 2, their roles are much more complicated, and to explain it all  fully 
is beyond this b ook. So I use the term participants , a word that isn't used formally in the UM L 



49/118 spec. In UML 1, par ticipants were objects and so their names were underlined, but in UML 2, they 
should be shown with out the under line, as I'v e done here. 
In these diagrams, I've named  the participants using the styl e anOrder . This works well most of the 
time. A fuller s yntax is name : Class , where both the name and the class are op tional, but you 
must keep  the colon if y ou use the class. ( Figure 4.4 , shown on page 58, uses  this style.) 
Each lifeline has an a ctivation bar that shows when the participant is ac tive in the interaction.  This 
corresponds to one of the par ticipant's methods being on the stack. Activa tion bars are optional  in 
UML, but I find them extremely valuable in clar ifying the behavior. My one excep tion is when 
exploring a design during a design session, because  they are awkward to draw on w hiteboards. 
Naming often is use ful to correlate participants  on the diagram. The cal l getProduct  is shown 
returning aProduct , which is the same name, and therefore the same par ticipant, as th e aProduct  
that the getPricingDetails  call is sent to. N ote that I've used a return arrow for only this call; I 
did that to show the correspondance. Some people use returns for all calls, but I prefer t o use the m 
only where they add information; otherwise, they simply clutter things. Even in  this case, you coul d 
probably leave the return out w ithout c onfusing your reader. 
The first message doesn't have a pa rticipant that sent it, as it comes from an undetermined s ource. 
It's called a found message . 
For an other approach to this scenario, take a look a t Figure 4.2 . The basic problem is still the same, 
but the way in which the par ticipants c ollaborate t o implement it is very different. The Order asks 
each Order Line to calculate its own Price. The Order Line itself further hands off  the calculation  to 
the Product; note how we show the pas sing of a parameter.  Similarly, to calculate the discount, th e 
Order invokes a method on the Customer. Because  it needs information fr om the Order to d o this, 
the Cust omer makes a reentrant ca ll (getBaseValue ) to the Order to get the data. 
Figure 4.2. A sequence diagram for distributed control 
 
The first thing to note ab out these two diagra ms is how clearly the sequence diagram indicates  the 
differences in how the participants interact. This is the great strength of interac tion diagrams. The y 
aren't g ood at showing details of algori thms, such as l oops and conditional behavior, but  they make 
the ca lls between participants crystal clear and give a really g ood picture ab out which participants 
are doing which processing. 
The second thing to n ote is the clear difference in styles between the tw o intera ctions. Figure 4 .1 is 
centralized control , with one participant pre tty much d oing all the processing and other 
participants there to supply data. Figure 4.2  uses distributed control , in which the proces sing is 
split among many participants, each one d oing a l ittle bit of the algorithm. 



50/118 Both styles have their strengths and weaknesses. Most people, particularly those new to objects, are 
more used to centra lized control. In many ways, it's simpler, as all the proces sing is in one place; 
with distributed control, in c ontrast, you have the sensa tion of cha sing around the objects, tr ying to 
find the program. 
Despite this, object bigots like me strongly pre fer distributed c ontrol. One of  the main goals of good 
design is t o localize  the effects of change. Data and behavior that accesses  that data often change 
together. So putting  the data and the behavior that uses it together  in one place is  the first rul e of 
object-oriented design. 
Furthermore, by distributing control, you create more oppor tunities for using polymorphism rather 
than using condi tional logic. If the algori thms for product pricing are different for different types of 
product, the distributed c ontrol mechanism allows us t o use subclasses of product t o handle these 
variations. 
In general the OO style is t o use a lot of little objects with a lot of  little methods that give us a lot of 
plug p oints for overriding and variation. This s tyle is very c onfusing to people used t o long 
procedures; indeed, this change is the heart of  the paradigm shift  of object orienta tion. It's 
something  that's very diffi cult to teach. It seems that  the only way to really  understand it is to work 
in an OO environment w ith strongly distribute d control for a while. Many people  then say that  they 
get a sudden "aha" when the style makes sense. At this p oint, their brains have been rewired, and 
they start t hinking  that decentralized c ontrol is actually easier. 
Creating and Deleting Part icipants 
Sequence diagrams show s ome extra notation  for creating and deleting participants  (Figure 4 .3). To 
create a pa rticipant, you draw  the message arrow directly  into the participant box. A message  name 
is optional here if you are using a constructor, but I usua lly mark it with "new" in any case. If the 
participant immediately does something once  it's created, such as the query c ommand, y ou start an 
activati on right after the participant box. 
Figure 4.3. Creation and deletion of participants 



51/118 
 
Deleti on of a participant is indicated by big X. A message arrow going int o the X indicates one 
participant explic itly deleting an other; an X at the end of a lifeline shows a participant dele ting itself. 
In a garbage-c ollected envir onment, y ou don't delete objects dire ctly, but it's still worth using  the X 
to indicate when an object is n o longer needed and is ready to be c ollected. It's also appropriat e for 
close operations, indicating that the object isn' t usable any more. 
Loops, Conditionals, and the Like 
A common issue w ith sequence diagrams is how to show l ooping and conditional behavior. The first 
thing t o point out is that this isn't what sequence diagrams are g ood at. If you want t o show contro l 
structures like  this, y ou are better off with an activity diagram or  indeed with code itself. Trea t 
sequence diagrams as a visualizati on of how objects interact rather  than as a way of mode ling 
control logic. 
That said, here's the nota tion to use. B oth loops and conditionals us e interaction frames , which 
are ways of marking off a piece of a sequence diagram. Figure 4 .4 shows a simple algor ithm based 
on the f ollowing pseudocode: 
Figure 4.4. Interaction frames 



52/118 
 
 
procedure dispatch 
  foreach (lineitem) 
    if (product.value > $10K) 
      careful.dispatch 
    else 
      regular.dispatch 
    end if 
  end for 
  if (needsConfirmation) messenger.confirm 
end procedure 
In general, frames consist of some region of a sequence diagram that is divided into one or more 
fragments. Each frame has an operator and each fragment may have a guard. ( Table 4.1  lists 
comm on operators for interac tion frames.) To show a l oop, you use the loop operand w ith a single 
fragment and put  the basis of the iteration  in the guard. For condi tional logic, you can use a n alt 
operator and put a condi tion on each fragment. Only the fragment whose guard is true will execute . 
If you have only one region, there is an opt operator. 
Intera ction frames are new in UML 2. As a resu lt, you may see diagrams prepared before UML 2 and 
that use a different approach; also, some people don't  like the frames and prefer some of the older 
conventi ons. Figure 4 .5 shows some of these u nofficial tweaks. 
Figure 4.5. Older conventions for control logic 



53/118 
 
UML 1 used iteration markers and guards. An iteration marker  is a * added t o the message name. 
You can add some text in square brackets t o indicate the basis of the iteration. Guards  are a 
conditional expressi on placed in square brackets and  indicate that the message is sent only if  the 
guard is true.  While these notations have bee n dropped fr om sequence diagrams in UML 2,  they are 
still legal on com munication diagrams. 
Table 4.1. Common Operators for Interaction Frames 
Operator  Meaning 
alt Alternative mu ltiple fragments; only the one w hose conditi on is true will execute ( Figure 
4.4). 
opt Optional; the fragment exe cutes only if  the supp lied condi tion is true. Equivalent to an 
alt with only one trace ( Figure 4.4 ). 
par Parallel; each fragment is run in parallel. 
loop Loop; the fragment may exe cute multiple times, and  the guard  indicates the basis of 
iteration ( Figure 4.4 ). 
region  Critical region; the fragment can have only on e thread executing it at once. 
neg Negative; the fragment shows an invalid interac tion. 
ref Reference; refers to an interaction defined on another diagram. The frame is drawn t o 
cover the lifelines involved in  the interaction. You can define parameters and a return 
value. 
sd Sequence diagram; used to surround an entire  sequence diagram, if you wish. 
Although itera tion markers and guards can help, they do have weaknesses. The guards can' t 
indicate that a set of guards are mutually exclusive, such as the two on Figure 4.5 . Both nota tions 
work only with a single message send and don' t work well when several messages coming out of a 
single ac tivation are w ithin the same l oop or conditional block. 
To get ar ound this last problem, an unofficial conventi on that's become popular is to use a 
pseudomessage , with the l oop condi tion or the guard on a variati on of the self-call nota tion. In 
Figure 4.5 , I've shown this with out a message arrow; some people include a message arrow, bu t 



54/118 leaving it out helps reinforce  that this isn't a real ca ll. Some also like to gray shade th e 
pseud omessage's activation bar. If you have a lterative behavior, you can show that with a n 
alternative marker between the activations. 
Although I find activa tions very helpful, they don't add much in the case of th e dispatch  method, 
whereby you send a message and nothing else happens within  the receiver's activation. A common 
conventi on that I've shown on Figure 4.5  is to drop the a ctivation for those simple calls. 
The UML standard has no graphic device to show passing data;  instead, it's shown by parameters in 
the message name and return arrows . Data tadpoles  have been ar ound in many methods t o 
indicate the movement of data, and many people s till like to use them w ith the UML. 
All in all, a lthough various schemes can add n otation for conditional logic t o sequence diagrams, I 
don't find that they work any better  than code or at least pseudocode. In particular, I find  the 
intera ction frames very heavy, obscuring the main p oint of the diagram, s o I prefer 
pseud omessages. 
Synchronous and Asynchronous Calls 
If you're exceptiona lly alert, you'll have n oticed that the arrowheads  in the last couple of diagrams 
are different from  the arrowheads ear lier on. That minor difference is qu ite important in UML 2. In 
UML 2, filled arrowheads show a synchronous  message, while stick arrowheads show an 
asynchronous message. 
If a caller sends a synchronous message , it must wait  until the message is done, such as invoking 
a subrou tine. If a caller sends a n asynchron ous message , it can con tinue processing and doesn' t 
have to wait for a response. You see asynchronous calls  in multithreaded app lications and in 
message-oriented middleware. Asynchrony gi ves better responsiveness and reduces the tempora l 
coupling but is harder to debug. 
The arrowhead difference is very subtle; indeed, rather t oo subtle. It's also a backward-incompa tible 
change introduced  in UML 1.4, before then an asynchronous message was shown with the half-stick 
arrowhead, as in Figure 4.5 . 
I think that this arrowhead distincti on is too subtle. If y ou want t o highlight asynchronous me ssages, 
I would recommend using the obsolete half- stick arrowhead, which draws the eye much better  to an 
important distinc tion. If you're reading a sequence diagram, beware of making assumpti ons abou t 
synchrony fr om the arrowheads unless you're sure that the author is intentionally making  the 
distinction. 
When to Use Sequence Diagrams 
You sh ould use sequence diagrams when you want t o look at the behavior of several objects within 
a single use case. Sequence diagrams are g ood at showing co llabora tions among the objects;  they 
are not so g ood at precise def inition of the behavior. 
If you want t o look at the behavior of a single object across many use cases, use a state diagram 
(see Chapter 10 ). If y ou want to l ook at behavior across many use cases or many  threads, c onsider 
an activity diagram (see Chapter 11 ). 
If you want t o explore multiple alternative interac tions quickly, you may be better off with CRC 
cards, as that avoids a l ot of drawing and eras ing. It's often handy t o have a CRC card sessi on to 
explore design alternatives and then use sequence diagrams t o capture any interactions that yo u 
want to refer t o later. 
Other useful forms of interaction diagrams are communication diagrams, for showing c onnections; 
and timing diagrams, for showing ti ming constraints. 



55/118 CRC Cards 
One of the m ost valuable tec hniques in c oming up with a g ood OO design is to explor e 
object interactions, because it f ocuses on behav ior rather  than data. CRC (Class-
Responsib ility-Collabora tion) diagrams, invented by Ward Cun ningham in the late 1980s , 
have st ood the test of  time as a highly effective way to d o this (Figure 4 .6). Although they 
aren't part of  the UML, they are a very popular technique among s killed object designers. 
Figure 4.6. A sample CRC card 
 
To use CRC cards, you and your c olleagues ga ther around a table. Take various scenarios 
and act them out with the cards, picking  them up in the air when they are active an d 
moving them to suggest how they send messages t o each other and pass them ar ound. 
This te chnique is almost  impossible to describe  in a book yet is easily demonstrated; th e 
best way to learn it is t o have someone who h as done it show it to you. 
An important part of CRC  thinking is identif ying responsibilities. A responsibility  is a 
short sentence that summarizes s omething  that an object sh ould do: an a ction the objec t 
performs, some knowledge the object ma intains, or some important decisions the objec t 
makes. The idea is  that you should be able t o take any class and summarize it w ith a 
handful of responsibilities. D oing that can help you think more clearly about the design of 
your classes. 
The second C refers t o collaborators : the oth er classes that this class needs to work 
with. This gives you s ome idea of  the links between classes—s till at a high level. 
One of the chief bene fits of CRC cards is that  they enc ourage animated discussi on amon g 
the developers. When you are wor king throug h a use case to see how classes wil l 
implement it, the interacti on diagrams  in this chapter can be slow to draw. Usually, you 
need to consider alternatives; w ith diagrams, the alternatives can take t oo long to dra w 
and rub out.  With CRC cards, y ou model the interaction by pic king up the cards and 
moving them ar ound. This a llows you to quickly consider alternatives. 
As you d o this, y ou form ideas about responsib ilities and write  them on  the cards. 
Thinking ab out responsibili ties is important, because  it gets you away from the no tion of 
classes as dumb data holders and eases the team members toward understanding the 
higher-level behavior of each class. A responsibility may correspond to an opera tion, to an 
attribute, or, more likely, to an undetermined clump of attributes and opera tions. 
A common mistake I see people make is generating long lists of low-level responsibilities . 
But d oing so misses the p oint. The resp onsibilities sh ould easily fit on one card. Ask 
yourself whether  the class sh ould be split or whether the responsib ilities would be bette r 



56/118 stated by r olling them up into higher-level statements. 
Many people stress the importance of role play ing, whereby each person on the team 
plays the role of one or more classes. I've never seen Ward Cunningham d o that, and I 
find that role playing gets in the way. 
Books have been wr itten on CRC, but I've f ound that  they never really get to the heart of 
the tec hnique. The original paper on CRC, written w ith Kent Beck, is [Beck and 
Cunningham]. To learn more ab out both CRC cards and responsib ilities in design, take a 
look at [ Wirfs-Brock]. 
 
Chapter 5. Class Diagrams: Advanced 
Concepts 
The concepts described i n Chapter 3  correspond t o the key notati ons in class diagrams. Thos e 
concepts are the first ones t o understand and become fam iliar with, as they will comprise 90 p ercent 
of your effort  in building class diagrams. 
The class diagram technique, however, has bred dozens of nota tions for add itional concepts. I find 
that I don't use these all the time, but they ar e handy when they are appropriate. I'll discuss them 
one at a time and point out some of the issues  in using them. 
You'll probably find  this chapter somewhat heavy g oing. The g ood news is that during your first pass 
through the b ook, you can safely skip this chapter and come back t o it later. 
 
Keywords 
One of the challenges of a graphical language is that you have t o remember what the symb ols 
mean.  With too many, users find  it very difficul t to remember what all the symbols mean. So th e 
UML often tries to reduce the number of symb ols and use keywords instead. If you find that y ou 
need a modeling construct that isn't  in the UML but is sim ilar to somet hing that is, use the symbol of 
the existing UML construct but mark it w ith a keyword t o show that you have s omething differen t 
An example of this is the  interface. A UML interface  (page 69) is a class that has only pub lic 
opera tions, with no method bodies. This corresponds to interfaces  in Java, COM (Comp onent Objec t 
Module), and CORBA. Because it's a special kind of class,  it is shown using the class icon with  the 
keyword «interface» . Keywords are usually shown as text between guillemets. As an alternative t o 
keywords, you can use special icons, but then you run int o the issue of everyone having t o 
remember what they mean. 
Some keywords, such as {abstract} , show up  in curly brackets. It's never really clear what shoul d 
technically be in gu illemets and what sh ould be in cur lies. Fortunately, if you get it wrong, only 
serious UML weenies will n otice—or care. 
Some keywords are so c ommon that they ofte n get abbreviated : «interface»  often gets 
abbreviated t o «I» and {abstract}  to {A}. Such abbreviations are very useful, particularly on 
whiteboards, but nonstandard, s o if you use them, make sure y ou find a spot to spell out what  they 
mean. 
In UML 1, the guillemets were used ma inly for stereotyp es. In UML 2, stere otypes are define d very 
tightly, and describing what is and isn't a stereotype is beyond the scope of this b ook. However , 



57/118 because of UML 1, many people use the ter m stereotype  to mean the same a s keyword , although 
that is n o longer correct. 
Stereotypes are used as part of profiles. A profile  takes a part of the UML and extends it with a 
coherent group of stereotypes for a pa rticular purpose, such as business mode ling. The f ull 
semantics of pr ofiles are beyond  this book. Unless you are into seri ous meta-model design, you're 
unlikely to need to create one y ourself. You're more likely to use one created for a specific modeling 
purpose, but fortunately, use of a profile doesn't require y ou to know the gory details of how  they 
are tied  into the meta-model. 
 
Classification and General ization 
I often hear people talk ab out subtyping as  the is a relationship. I urge you to beware of  that way of 
thinking. The problem is that the phrase is a can mean different  things. 
Consider the f ollowing phrases. 
1. Shep is a Border Collie. 
2. A Border C ollie is a Dog. 
3. Dogs are Animals. 
4. A Border C ollie is a Breed. 
5. Dog is a Species. 
Now try comb ining the phrases. If I combine phrases 1 and 2, I get "Shep is a Dog"; 2 and 3 take n 
together yield "Border Collies are Animals." And 1 plus 2 plus 3 gives me "Shep is an Animal." So 
far, so g ood. Now try 1 and 4: "Shep is a Breed." The combination of 2 and 5 is "A Border Collie is a 
Species." These are not so g ood. 
Why can I combine some of these phrases and not others? The reason is that some ar e 
classification —the object Shep is an instance of the type Border C ollie—and some ar e 
generalizati on—the type Border Collie is a subtype of the type Dog. Genera lization is transitive; 
classifica tion is not. I can combine a classifica tion followed by a generaliza tion but n ot vice versa. 
I make this p oint to get you to be wary of is a. Using  it can lead t o inappropriate use of subclassing 
and confused responsibilities. Better tests for subtyping in this case w ould be the phrases "Dogs are 
kinds of Animals" and "Every instance of a Border C ollie is an instance of a Dog." 
The UML uses the generaliza tion symb ol to show generalization. If y ou need to show classification, 
use a dependency with th e «instantiate»  keyword. 
 
Multiple and Dynamic Classification 
Classification  refers t o the rela tionship between an object and its type. Mainstream program ming 
languages assume that an object belongs to a single class. But  there are more op tions to 
classifica tion than that. 
In single classificati on, an object belongs to a single type, which may inherit fr om supertypes. I n 
multiple classificati on, an object may be described by several types that are not necessarily 
connected by inheritance. 
Multiple classification is different from m ultiple inheritance. Mul tiple inheritance says that a type ma y 
have many supertypes but that a single type must be de fined for each object. M ultiple classifica tion 
allows multiple types for an object without defi ning a specific type for  the purpose. 



58/118 For example, consider a person subtyped as e ither man or woman, d octor or nurse, patient or  not 
(see Figure 5. 11). Multiple classification a llows an object t o have any of these types assigned t o it in 
any a llowable combination, without the need for types to be defined for all the legal combina tions. 
Figure 5. 11. Multiple classification 
 
If you use mu ltiple classification, y ou need to be sure that you make it clear which combinati ons are 
legal. UML 2 does this by placing each generaliza tion relati onship into a generalization set . On the 
class diagram, you label the genera lization arrowhead with the name of the genera lization set, which 
in UML 1 was called the discriminator. Single classification corresponds to a single genera lization se t 
with no name. 
Generaliza tion sets are by defa ult disjoint: Any instance of  the supertype may be an instance of only 
one of  the subtypes w ithin that set. If y ou roll up generalizati ons into a single arrow, they mus t all 
be part of the same generalizati on set, as shown i n Figure 5. 11. Alternatively, y ou can have severa l 
arrows with the same text label. 
To illustrate, note the fo llowing legal combinations of subtypes  in the diagram: (Female, Pa tient, 
Nurse); (Male, Physiotherapist); (Female, Patient); and (Female, Doctor,  Surgeon). The combina tion 
(Patient, Doctor, Nurse) is illegal because it contains tw o types from  the role generalization set. 
Another ques tion is whether an object may change its class. For example, when a bank account  is 
overdrawn,  it substa ntially changes its behavior. Specifically, several opera tions, including 
"withdraw" and "close," get overridden. 
Dynamic classificati on allows objects t o change class wi thin the subtyping structure; static 
classification  does not.  With sta tic classifica tion, a separati on is made between types and states; 
dynamic classificati on combines  these n otions. 
Should y ou use multiple, dynamic classificati on? I believe that it is useful for conceptual mode ling. 
For software perspectives, however, the distance between it and the implementations is t oo much of 
a leap. In the vast ma jority of UML diagrams, you'll see only single static classifica tion, so that 
should be your defau lt. 
 
Association Class 
Association classes  allow you to add attributes, operations, and other features to ass ociations, as 
shown in Figure 5. 12. We can see fr om the diagram that a person may a ttend many meetings. We 



59/118 need to keep informa tion ab out how awake that pers on was; we can d o this by adding the attribut e 
attentiveness t o the ass ociation. 
Figure 5. 12. Association class 
 
Figure 5.13  shows an other way to represent  this informa tion: Make Attendance a full class in its  own 
right. N ote how the m ultiplicities have moved. 
Figure 5. 13. Promoting an association class to a full class 
 
What benefit d o you gain w ith the ass ociation class to offset  the extra notati on you have t o 
remember? The associa tion class adds an extra constra int, in that  there can be only one instance of 
the ass ociation class between any two participating objects. I feel the need for another example . 
Take a l ook at the tw o diagrams  in Figure 5.14 . These diagrams have  much the same form. 
However, we can imagine one Company playing different roles in  the same Contract, but it's harder 
to imagine a Person having multiple competen cies in the same skill; indeed, you w ould probabl y 
consider  that an error. 
Figure 5. 14. Association class subtleties (Role should probably not be an 
association class) 



60/118 
 
In the UML, only the latter case is legal. You can have only one competency for each combina tion of 
Person and Skill. The top diagram in Figure 5. 14 would not allow a Company t o have more than  one 
Role on a single c ontract. If you need to a llow this, you need t o make Role a full class, in  the style of 
Figure 5.13 . 
Implementing association classes isn't terribly obvi ous. My advice is t o implement an associa tion 
class as if it where a full class but to provide methods that get informati on to the classes  linked by 
the ass ociation class. So fo r Figure 5.12 , I would see  the following methods on Person: 
 
class Person 
  List getAttendances() 
  List getMeetings() 
This way, a client of Person can get hold of th e people at the meeting; if they want details, they ca n 
get the Attendances themselves. If you do this, remember to enforce the c onstraint that there can 
be only one Attendance object for any pair of Person and Meeting. Y ou should place a check in 
whichever method creates  the Attendance. 
You often find this kind of construct with  historical information, such as  in Figure 5.15 . However, I 
find that crea ting extra classes or associa tion classes can make the model tricky t o understand, as 
well as t ilt the implementa tion in a particular direction  that's often  unsuitable. 
Figure 5. 15. Using a class for a temporal relationship 
 
If I have  this kind of temporal  information, I use a «temporal»  keyword on the ass ociation (see 
Figure 5.16 ). The model indicates that a Pers on may work for only a single Company at one t ime. 



61/118 Over time, however, a Person may work for s everal Companies. This suggests an interface al ong the 
lines of: 
Figure 5. 16. «Temporal»  keyword for associations 
 
 
class Person ... 
  Company getEmployer();//get current employer 
  Company getEmployer(Date);//get employer at a given date 
  void changeEmployer(Company newEmployer,Date changeDate); 
  void leaveEmployer (Date changeDate); 
The «temporal»  keyword is not part of the UML, but I men tion it here for two reas ons. First, it is a 
notion I have f ound useful on several occasions in my modeling career. Second, it shows how you 
can use keywords to extend the UML. You can read a lot more ab out this at 
http://martinfowler.com/ap2/timeNarrative.ht ml. 
Template (Parameterized) Class 
Several languages, m ost noticeably C++, have  the notion of a parameterized class , or template . 
(Templates are on the list to be in cluded in Java and C# in the near future.) 
This concept is m ost obviously useful for wor king with c ollections in a strongly typed language. This 
way, you can de fine behavior for sets  in general by defining a template clas s Set. 
 
class Set <T> { 
  void insert (T newElement); 
  void remove (T anElement); 
When y ou have done this, you can use the general defin ition to make Set classes for more spe cific 
elements: 
 
Set <Employee> employeeSet; 
You declare a template class in the UML by us ing the nota tion shown  in Figure 5.17 . The T in  the 
diagram is a placeholder for the type parameter. (Y ou may have more than one.) 
Figure 5. 17. Template class 
 
A use of a parameterized class, such a s Set<Employee> , is called a derivati on. You can show a 
deriva tion in two ways. The first way mirrors the C++ syntax (see Figure 5. 18). You describe th e 
deriva tion expression within angle brackets  in the for m <parameter-name::parameter-value> . If 



62/118 there's only one parameter, c onventional use often omits the parameter name. The a lternative 
notati on (see Figure 5.19 ) reinforces the link t o the template and allows you to rename the b ound 
element. 
Figure 5. 18. Bound element (version 1) 
 
Figure 5. 19. Bound element (version 2) 
 
The «bind»  keyword is a stere otype on the re finement relationship. This relati onship indicates that 
EmployeeSet  will conform to the  interface of Set. You can think of th e EmployeeSet  as a subtype of 
Set. This fits the other way of implementing type-specific collecti ons, which is to declare al l 
appropriate subtypes. 
Using a deriva tion is not the same as subtyping, however. Y ou are n ot allowed to add features  to the 
bound element, which is completely specified by its template; you are adding only restricting type 
informa tion. If you want to add features, you  must create a subtype. 
 
Enumerations 
Enumerati ons (Figure 5.20 ) are used to show a fixed set of values that don't have any properties 
other than their symbolic value. They are shown as the class with the «enumeration»  keyword. 
Figure 5. 20. Enumeration 



63/118 
 
 
Active Class 
An active class  has instances, each of which executes and c ontrols its own  thread of control. 
Method  invoca tions may execute in a client's t hread or in  the active object's  thread. A g ood exampl e 
of this is a command processor that accepts command objects from the outside and  then executes 
the commands within its own thread of control. 
The notation for active classes has changed from UML 1 to UML 2, as shown  in Figure 5.21 . In UML 
2, an ac tive class has extra ve rtical lines on the side; in UML 1,  it had a thick border and was called 
an active object. 
Figure 5. 21. Active class 
 
 
Visibilit y 
Visibility  is a subject that is simple in principle but has complex subtleties. The simple idea is  that 
any class has public and private elements. Public elements can be used by any other class; private 
elements can be used only by the owning class. However, each language makes its own rules. 
Although many languages use such terms a s public, private, and protected , they mean differe nt 
things in different languages. These differences are small, but  they lead t o confusion, especiall y for 
those of us wh o use more than one language. 
The UML tries to address  this without getting into a horrible tangle. Essen tially, w ithin the UML, you 
can tag any attribute or operati on with a visibil ity indicator. Y ou can use any marker you  like, and its 
meaning is language dependent. However, the UML provides four abbrevia tions for visibility : + 
(public) , – (private), ~ (package), and # (protected). These four levels are used wi thin the UM L 
meta-model and are defined wit hin it, but thei r definitions vary subtly fr om those  in other 
languages. 
When y ou are u sing visibility, use the rules of the language in which you are working.  When you are 
looking at a UML model from elsewhere, be wary of the meanings of  the visibility markers, and be 
aware of how those meanings can change from  language to language. 



64/118 Most of the time, I don't draw visibi lity markers in diagrams; I use them only if I need t o highligh t 
the differences  in visib ility of certain features. Even then, I can m ostly get away w ith + and –, which 
at least are easy t o remember. 
Message s 
Standard UML does n ot show any informa tion about message calls on class diagrams. However, I've 
sometimes seen c onventional diagrams like Figure 5.22 . 
Figure 5. 22. Classes with message s 
 
These add arrows to the sides of associations. The arrows are labeled with the messages  that one 
object sends to an other. Because you don't need an ass ociation to a class to send a message to it, 
you may als o need to add a dependency arrow  to show messages between classes  that aren' t 
associated. 
This message informa tion spans  multiple use cases, s o they aren't numbered to show sequences, 
unlike com munication diagrams. 
 
Responsibilities 
Often, it's handy t o show resp onsibilities (pag e 63) on a class in a class diagram. The best way t o 
show them is as c omment strings in their own  compartment in the class ( Figure 5.1 ). You can name 
the compa rtment, if you wish, but I usually don't, as  there's rarely any poten tial for c onfusion. 
Figure 5.1. Showing responsibilities in a class diagram 



65/118 
 
 
Static Operations and Attributes 
The UML refers to an operation or an attribute  that applies to a class rather than to an  instance as 
static . This is equivalent to sta tic members in C-based languages. Static features are underlined on 
a class diagram (see Figure 5 .2). 
Figure 5.2. Static notation 
 
Aggregation and Composition 
One of the m ost frequent sources of confusion in the UML is aggrega tion and comp osition. It's easy 
to explain glibly: Aggregation  is the part-of rela tionship. It's like sa ying that a car has an engine 
and wheels as its parts. This sounds g ood, but  the diffi cult thing is considering what the difference is 
between aggregation and ass ociation. 
In the pre-UML days, people were usually rather vague on what was aggrega tion and what was 
associa tion. Whether vague or not,  they were always inconsistent with everyone else. As a result, 
many modelers think that aggregation is important, although for different reasons. So the UML 
included aggregati on (Figure 5 .3) but with hardly any semantics. As Jim Rumbaugh says, " Think of it 
as a modeling placebo" [Rumbaugh, UML Reference]. 
Figure 5.3. Aggregation 
 



66/118 As well as aggregation, the UML has the more defined property of composition . In Figure 5 .4, an 
instance of P oint may be part of a polyg on or may be the center of a circle, but it cannot be b oth. 
The general rule is that, a lthough a class may be a component of many other classes, any instance 
must be a component of only one owner. The class diagram may show multiple classes of poten tial 
owners, but any instance has only a single object as its owner. 
Figure 5.4. Composition 
 
You'll note  that I don't show the reverse m ultiplicities in Figure 5.4 . In m ost cases, as here, it's 0..1. 
Its only other possible value is 1, for cases in which  the component class is designed so that it  can 
have only one other class as its owner. 
The "no sharing" rule is the key to comp osition. An other as sumption is that if you delete the 
polygon, it sh ould automatically ensure that any owned P oints also are deleted. 
Compositi on is a g ood way of showing properties that own by value, prope rties to value objects 
(page 73), or properties that have a strong an d somewhat exclusive ownership of particular other 
components. Aggregati on is strictly meaningle ss; as a result, I recommend  that you ignore  it in your 
own diagrams. If y ou see it in other people's diagrams, you'll need to dig deeper to find out wha t 
they mean by  it. Different authors and teams use it for very different purposes. 
 
Derived Properties 
Derived properties  can be cal culated based on other values.  When we  think about a date range 
(Figure 5.5 ), we can think of three proper ties: the start date, the end date, and the number of days 
in the period. These values are  linked, so we can think of the length as being derived fr om the other 
two values. 
Figure 5.5. Derived attribute in a time period 
 
Deriva tion in s oftware perspe ctives can be interpreted in a couple of different ways. You can use 
deriva tion to indicate the difference between a calculated value and a stored value. In  this case, we 
would interpre t Figure 5 .5 as indica ting that the start and end are stored but that the length is 
computed. Although this is a c ommon use, I'm  not so keen, because it reveals t oo much of  the 
internals of DateRange . 
My preferred thin king is that it indicates a c onstraint between values. In this case, we are saying 
that the constraint among the three values holds, but it isn't important which of the three values is 
computed. In this case, the choice of which attribute t o mark as derived is arbitrary and strictly 
unnecessary, but it's useful to help re mind people of the constraint. This usage also makes se nse 
with conceptual diagrams. 



67/118 Deriva tion can also be applied to properties us ing association nota tion. In  this case, you simpl y 
mark the name with a /. 
 
Interfaces and Abstract Classes 
An abstract cla ss is a class that cann ot be directly instantiated. Instead, you  instan tiate an 
instance of a subclass. Typically, an abstract class has one or more operations that are abstract. An 
abstract operati on has n o implementation; it  is pure declaration so that c lients can bind to th e 
abstract class. 
The m ost common way to indicate an abstract class or operation in the UML is t o italicize  the name. 
You can als o make proper ties abstract, indicat ing an abstract property or accessor methods.  Italics 
are tricky to do on a whiteboards, so you can use the label: {abstract} . 
An interface is a class that has n o implementat ion; that is, a ll its features are abstract. Interfaces 
correspond directly to interfaces in C# and Java and are a comm on idiom  in other typed languages. 
You mark an  interface with the keywor d «interface» . 
Classes have two kinds of relation ships with  interfaces: pr oviding and requiring. A class provides 
an interface  if it is substitutable for the  interface. In Java and .NET, a class can d o that by 
implementing  the interface or implemen ting a subtype of the interface. In C++, you subclass the 
class that is the interface. 
A clas s requires an interface  if it needs an i nstance of  that interface in order to work. Esse ntially, 
this is having a dependency on the interface. 
Figure 5.6  shows  these relation ships in action, based on a few c ollection classes fr om Java. I might 
write an Order  class that has a list of  line items. Because I'm using a list, th e Order  class is 
dependent on the List interface. Let's assume  that it uses the methods equals , add, and get. 
When the objects c onnect, th e Order  will a ctually use an instance of ArrayList  but need n ot know 
that in order t o use those  three methods, as they are all part of the List interface. 
Figure 5.6. A Java example of interfaces and an abstract class 



68/118 
 
The ArrayList  itself is a subclass of  the AbstractList  class. AbstractList  provides some, but n ot 
all, the implementati on of th e List behavior. I n particular,  the get method is abstract. As a re sult, 
ArrayList  implement s get but also overrides some of the other operati ons on AbstractList . In 
this case,  it overrides add but is happy t o inherit the implementati on of equals . 
Why don't I simply avoid this and hav e Order  use ArrayList  directly? By u sing the interface, I a llow 
myself the advantage of making it easier t o change implementa tions later on if I need to. An other 
implementati on may pr ovide performance improvements, s ome database  interacti on features, o r 
other benefits. By programming t o the interface rather than t o the implementation, I avoid having t o 
change all the code sh ould I need a different implementati on of List. You sh ould always try t o 
program to an interface like this; always use  the most general type y ou can. 
I should also p oint out a pragmatic wrinkle in  this. When programmers use a co llection like this, 
they usually  initialize the co llection with a declara tion, like this: 
 
private List lineItems = new ArrayList(); 
Note that this strictly introduces a dependency from Order  to the concrete ArrayList . In theory, 
this is a problem, but people don't worry ab out it in prac tice. Because the type of lineItems  is 
declared as List, no other part of the Order  class is dependent on ArrayList . Should we change 
the implementation, there's only this one  line of initialization code that we need to worry about. It' s 
quite common to refer to a concrete class onc e during crea tion but t o use only the interfac e 
afterward. 
The full notati on of Figure 5.6  is one way to notate interfaces . Figure 5 .7 shows a more compac t 
notation. The fact tha t ArrayList  implement s List and Collection  is shown by having ball icons, 
often referred to as lollipops, out of it. The fact  that Order  requires a List interface is shown by th e 
socket icon. The c onnection is nicely obvious. 
Figure 5.7. Ball-and-socket notation 



69/118 
 
The UML has used the l ollipop notati on for a w hile, but the socket nota tion is new to UML 2. (I  think 
it's my favorite nota tional addi tion.) You'll probably see older diagrams use the style of Figure 5 .8, 
where a dependency stands in for the s ocket notation. 
Figure 5.8. Older dependencies with lollipops 
 
Any class is a mix of an  interface and an implementation. Therefore, we may often see an objec t 
used through  the interface of one of its superclasses. Stri ctly, it wouldn't be legal to use  the lol lipop 
notati on for a superclass, as  the superclass is a class, not a pure interface. But I bend these rules 
for clarity. 
As well as on class diagrams, people have f ound lollipops useful elsewhere. One of the perennia l 
problems w ith intera ction diagrams is  that the y don't pr ovide a very g ood visua lization for 
polymorphic behavior. Although it's not norma tive usage, you can indicate this along  the lines of 
Figure 5.9 . Here, we can see  that, although we have an  instance of Salesman, which is used as such 
by the B onus Cal culator, the Pay Period object  uses the Salesman only through its Employe e 
interface. (You can do the same trick with c ommunication diagrams.) 
Figure 5.9. Using a lollipop to show polymorphism in a sequence diagram 



70/118 
 
Read-Only and Frozen 
On page 37, I described th e {readOnly}  keyword. You use this keyword to mark a property  that ca n 
only be read by c lients and that cann ot be updated. Sim ilar yet different is th e {frozen}  keyword 
from UML 1. A property is frozen  if it cannot change during the  lifetime of an object; suc h 
properties are often called im mutable. Although it was dropped fr om UML 2, {frozen}  is a very 
useful concept, s o I would continue to use it. As well as marking individual properties as frozen, you 
can apply the keyword to a class to indicate that all properties of all instances are frozen. (I have 
heard  that frozen may well be reinstated shor tly.) 
 
Reference Objects and Value Objects 
One of the c ommon t hings said ab out objects is that they have identity. This is true, but it is n ot 
quite as simple as that. In practice, you find that ide ntity is important for reference objects but no t 
so important for value objects. 
Reference objec ts are such things as Customer. Here, identity is very important because y ou 
usually want only one software object to designate a cust omer in the real world.  Any object tha t 
references a Customer object will do s o through a reference, or pointer; all objects that refere nce 
this Customer will reference the same s oftware  object. That way, changes to a Customer ar e 
available to all users of the Cust omer. 
If you have tw o references to a Customer and wish to see whether they are the same, you usually 
compare their ident ities. Copies may be disallowed; if they are allowed, they tend to be made rarely , 
perhaps for archive purposes or for replication across a network. If copies are made, y ou need  to 
sort out how to synchronize changes. 
Value objects  are such  things as Date. You often have mu ltiple value objects represen ting the 
same object in the real world. For example, it is normal to have hundreds of objects that designate 
1-Jan-04. These are all interchangeable copies. New dates are created and destroyed frequently. 



71/118 If you have two dates and wish to see whether they are the same, you don't l ook at their identities 
but rather at the values they represent. This usually means  that you have to write an equality tes t 
operator, which for dates would make a test on year, month, and day—or whatever the  interna l 
representation is. Each object that references 1-Jan-04 usually has its own dedicated object, but you 
can also share dates. 
Value objects should be immutable; in other words, y ou should not be able to take a date object of 
1-Jan-04 and change the same date object to be 2-Jan-04. Instead, y ou should create a new 2-Jan-
04 object and use that instead. The reason is  that if the date were shared, y ou would updat e 
another object's date  in an unpredictable way, a problem referred to as aliasing . 
In days gone by, the difference between reference objects and value objects was clearer. Valu e 
objects were the b uilt-in values of the type system. Now y ou can extend  the type system with  your 
own classes, s o this issue requires more thought. 
The UML uses the c oncept of data type , which is shown as a keyword on the class symbol. Stric tly, 
data type isn't the same as value object, as data types can't have identity. Value objects may have 
an ide ntity, but don't use it for equa lity. Primitives in Java w ould be data types, but dates would not, 
although they would be value objects. 
If it's important to hig hlight them, I use comp osition when associating with a value object. Y ou can 
also use a keyword on a value type; common conventional ones I see are «value»  or «struct» . 
Qualified Associations 
A qualified association  is the UML equivalent  of a progra mming concept variously known as 
associative arrays, maps, hashes, and dictionaries. Figure 5.10  shows a way that uses a qualifier t o 
represent the ass ociation between the Order and Order Line classes. The qualifier says that in 
connecti on with an Order, there may be one Order Line for each  instance of Product. 
Figure 5. 10. Qualified association 
 
From a software perspective, this qua lified associati on would imply an interface along the lines  of 
 
class Order ... 
  public OrderLine getLineItem(Product aProduct); 
  public void addLineItem(Number amount, Product forProduct); 
Thus, all access to a given Order Line requires a Product as an argument, suggesting an 
implementati on using a key and value data structure. 
It's common for people to get c onfused about the mul tiplicities of a qualified ass ociation. I n Figure 
5.10, an Order may have many Line Items, bu t the mu ltiplicity of  the qualified ass ociation is th e 
multiplicity in the c ontext of the qualifier. S o the diagram says  that an Order has 0..1 Line Ite ms per 
Product. A  multiplicity of 1 w ould indicate  that Order w ould have t o have a Line Item for every 
instance of Product. A * would  indicate that you would have mu ltiple Line Items per Product bu t that 
access t o the Line Items is indexed by Product. 
In conceptual modeling, I use  the qualifier c onstruct only to show constraints along the  lines of 
"single Order Line per Product on Order." 
 



72/118 Chapter 6. Object Diagrams 
An object diagram  is a snapshot of the objects in a system at a p oint in time. Because it show s 
instances rather than classes, an object diagram is often called an  instance diagram. 
You can use an object diagram to show an ex ample configuration of objects. (See Figure 6.1 , which 
shows a set of classes, and Figure 6.2 , which shows an associated set of objects.) This latter use i s 
very useful when the possible connecti ons between objects are complicated. 
Figure 6.1. Class diagram of Party composition structure 
 
Figure 6.2. Object diagram showing example instances of Part y 
 
You can tell that the elements i n Figure 6.2  are instances because the names are underlined. Each 
name takes  the form instance name : class name . Both parts of the name are optional, s o John, 
:Person , and aPerson  are legal names. If you  use only the class name, y ou must in clude the c olon. 
You can show values for attributes and links, a s in Figure 6.2 . 
Strictly, the elements of an object diagram are instance specifications rather than true instanc es. 
The reason is that it's legal t o leave mandatory a ttributes empty or to show instance specifica tions 
of abstract classes. You can t hink of an instance specification  as a partly defined instance. 
Another way of l ooking at an object diagram is as a c ommunication diagram (page 131) with out 
messages. 
 
When to Use Object Diagrams 



73/118 Object diagrams are use ful for showing examples of objects connected together.  In many situa tions, 
you can define a structure precisely with a class diagram, but the structure is still difficult t o 
understand.  In these situations, a couple of object diagram examples can make all  the difference. 
Chapter 7. Package Diagrams 
Classes represent the basic form of structuring an object-oriented system.  Although they are 
wonderfully useful, you need s omething more to stru cture large systems, which may have  hundreds 
of classes. 
A package  is a grouping construct that allows you to take any construct in  the UML and group its 
elements together into higher-level  units. Its most common use is to group classes, and that's  the 
way I'm describing it here, but remember that you can use packages for every other b it of the UML 
as well. 
In a UML model, each class is a member of a single package. Packages can also be members of 
other packages, s o you are left with a hierarchic stru cture in which top-level packages get broken 
down into subpackages w ith their own subpackages and so on until  the hierarchy bo ttoms out in 
classes. A package can c ontain both subpackages and classes. 
In programming terms, packages correspond t o such grouping constructs as packages (in Java) and 
namespaces (in C++ and .NET). 
Each package represents a namespa ce, which means that every class  must have a unique n ame 
within its ow ning package. If I want to create a class ca lled Date, and a Date class is already in th e 
System package, I can have my Date class as long as I put it in a separate package. To make i t 
clear which is which, I can use a fully qualified na me, that is, a name that shows the ownin g 
package structure. You use double colons t o show package names  in UML, so the dates might b e 
System::Date  and MartinFowler::Util::Date . 
In diagrams, packages are shown with a tabbe d folder, as in Figure 7.1 . You can simply show the 
package name or show the c ontents t oo. At any point, y ou can use fully qualified names or simply 
regular names. Showing  the contents with class ic ons allows you to show all  the details of a cl ass, 
even t o the point of showing a class diagram within the package. Simply listing the names makes 
sense when all you want to d o is indicate which classes are in which packages. 
Figure 7.1. Ways of showing packages on diagrams 



74/118 
 
It's quite c ommon to see a class labeled something lik e Date (from java.util)  rather than  the 
fully qualified form. This style is a conven tion that was done a lot by Rational Rose; it isn't par t of 
the standard. 
The UML a llows classes in a package t o be pub lic or private. A public class is part of the interface of 
the package and can be used by classes  in other packages; a private class is hidden. Differen t 
programming envir onments have different rules about visibility between their packaging constructs ; 
you sh ould follow the conven tion of your programming environment, even if it means bending the 
UML's rules. 
A use ful technique here is t o reduce  the interface of the package by exporting only a small subset of 
the operati ons associated with  the package's pub lic classes. You can d o this by giving all class es 
private visibility, s o that they can be seen only by other classes in the same package, and by addin g 
extra public classes for the public behavior. These extra classes, calle d Facades  [Gang of F our], then 
delegate public operati ons to their shyer companions in the package. 
How do y ou choose which classes to put in which packages? This is a ctually quite an involve d 
question that needs a g ood bit of design skill to answer. Two useful principles are the C ommon 
Closure Principle and C ommon Reuse Principle [Martin]. The Common Cl osure Principle says  that th e 
classes in a package should need changing for similar reasons. The C ommon Reuse Principle says 
that classes  in a package should all be reused together. Many of the reas ons for grouping clas ses in 
packages have to do with the dependencies between the packages, which I'll come t o next. 
Packages and Dependencies 
A package diagram  shows packages and their dependencies. I  introduced the concept of 
dependency on page 47. If y ou have packages for presentation and domain, you have a dependenc y 
from the presenta tion package to the domain package if any class in the presenta tion package  has a 
dependency to any class in the domain package. In this way, interpackage dependencies summarize 
the dependencies between  their contents. 
The UML has many varieties of dependency, each w ith particular semantics and stereotype. I f ind it 
easier to begin with  the unstereotyped dependency and use the more particular dependencies only if 
I need to, which I hardly ever do. 



75/118 In a medium t o large system, plot ting a package diagram can be one of the most valuable t hings 
you can d o to control the large-scale structure of the system. Ideally, this diagram should be 
generated fr om the code base itself, so that you can see what is really there in the system. 
A good package structure has a clear flow to the dependencies, a concept  that's diffic ult to define 
but often easier to recognize. Figure 7.2  show s a sample package diagram for an enterprise 
application, one that is well-structured and has a clear flow. 
Figure 7.2. Package diagram for an enterprise application 
 
Often, you can identify a clear flow because all  the dependencies run in a single direction. A lthough 
that is a g ood indicator of a well-structured system, the data mapper packages of Figure 7 .2 show 
an excep tion to that rule of thumb. The data mapper packages act as an insula ting layer between 
the domain and database packages, an example of the Mapper pattern [Fowler, P of  EAA]. 
Many authors say that there sh ould be n o cycles in the dependencies (the Acyclic Dependency 
Principle [Ma rtin]). I don't treat that as an abs olute rule, but I d o think that cycles sh ould be 
localized and  that, in particular, you shouldn't have cycles that cross layers. 
The more dependencies coming into a package, the more stable the package's interface needs to be, 
as any change in its  interface will ripple into all the packages that are dependent on it (the Stable 
Dependencies Principle [Martin]). So in Figure 7 .2, the asset domain package needs a more stable 
interface  than the lea sing data mapper package. Often, you'll find  that the more stable package s 
tend t o have a higher proporti on of interfaces and abstract classes (the  Stable Abstractions Pr inciple 
[Martin]. 
The dependency relationships are not trans itive (page 48). T o see why this is important for 
dependencies, l ook at Figure 7.2  again. If a class in the asset domain package changes, we ma y 
have a change to classes w ithin the leasing d omain package. But this change does not necessarily 
ripple through t o the leasing presenta tion. (It ripples only if  the leasing domain changes its 
interface.) 



76/118 Some packages are used in so many places  that it w ould be a mess to draw all the dependency  lines 
to them. In this case, a conventi on is to use a  keyword, such as «global» , on the package. 
UML packages also define constructs to allow packages t o import and merge classes from one 
package into an other, using dependencies with keywords t o notate this. However, rules for this kind 
of thing vary grea tly with programming languages. On the wh ole, I find the general n otion of 
dependencies to be far more useful in practice. 
Package Aspects 
If you t hink abou t Figure 7 .2, you'll rea lize that the diagram has tw o kinds of structures. One i s a 
structure of layers  in the applica tion: presentat ion, domain, data mapper, and database. The other 
is a structure of subject areas: leasing and assets. 
You can make this more apparent by separating the two aspects, as i n Figure 7 .3. With this 
diagram, y ou can clearly see each aspect. However, these two aspects aren't true packages, 
because you can't assign classes to a single package. (You w ould have to pick one from each 
aspect.) This problem mirrors the problem in  the hierarchic namespaces in progra mming languages. 
Although diagrams lik e Figure 7 .3 are nonstandard UML, they are often very helpful  in explai ning the 
structure of a complex applica tion. 
Figure 7.3. Separating Figure 7.2  into two aspects 
 
 
Implementing Packages 
Often, you'll see a case in which one package defines an  interface that can be implemented by a 
number of other packages, such as that of Figure 7.4 . In this case,  the realizati on relation ship 
indicates that the database gateway defines an interface and that the other gateway classes provide 
an implementation. In pra ctice, this would mean that  the database gateway package c ontains 
interfaces and abstract classes that are fully implemented by the other packages. 



77/118 Figure 7.4. A package implemented by other packages 
 
It's quite c ommon for an interface and its implementati on to be in separate packages. Indeed, a 
client package often contains an interface for a nother package to implement: the same no tion of 
required  interface that I discussed on page 70. 
Imagine that we want to provide s ome user interface (UI) controls to turn  things on and off. We 
want this to work with a l ot of different things, such as heaters and lights. The UI c ontrols nee d to 
invoke methods on the heater, but we don't want the c ontrols to have a dependency t o the heater. 
We can avoid this dependency by de fining in the c ontrols package an interface  that is then 
implemented by any class that wants to work with these c ontrols, as in Figure 7.5 . This is a n 
example of the pattern Separated Interface [Fowler, P of EAA]. 
Figure 7.5. Defining a required interface in a client package 
 
When to Use Package Diagrams 



78/118 I find package diagrams extremely useful on larger-scale systems to get a picture of  the 
dependencies between ma jor elements of a sy stem. These diagrams correspond well to c ommon 
programming structures. Plotting diagrams of packages and dependencies helps you keep an 
application's dependencies under control. 
Package diagrams represent a compile-time grouping mechanism. For showing how objects are 
composed at runtime, use a composite structure diagram (page 135). 
Where to Find Out More 
The best discussi on I know of packages and how t o use them is [Martin]. Robert Ma rtin has long had 
an alm ost pathological obsession with dependencies and writes well about how to pay attenti on to 
dependencies s o that you can c ontrol and minimize them. 
 
Chapter 8. Deployment Diagrams 
Deployment diagrams show a system's physical lay out, revealing which pieces of software run on 
what pieces of hardware. Deployment diagrams are really very simple; hence the short chapter . 
Figure 8.1  is a simple example of a depl oyment diagram. The main items on the diagram are nodes 
connected by c ommunicati on paths. A node  is something that can h ost some software. Nodes come 
in two forms. A device  is hardware, it may be a computer or a simpler piece of hardware c onnected 
to a system.  An execution environment  is software that  itself h osts or c ontains other software, 
examples are an operating system or a c ontainer process. 
Figure 8.1. Example deployment diagram 
 



79/118 The nodes c ontain artifacts , which are  the ph ysical manifestati ons of software: usually, files. These 
files might be executables (such as .exe files, binaries, DLLs, JAR files, assemblies, or scripts), or 
data files, configuration files, HTML documents, and so on. Listing an ar tifact wit hin a node shows 
that the artifact is deployed t o that node in the running system. 
You can show a rtifacts either as class boxes or by listing  the name wit hin a node. If you show them 
as class boxes, you can add a d ocument ic on or th e «artifact»  keyword. You can tag nodes or 
artifacts with tagged values to indicate various interesting informa tion ab out the node, such a s 
vendor, operating system, location, or anything else that takes your fancy. 
Often, you'll have multiple physical nodes carr ying out the same logical task. You can either show 
this with  multiple node boxes or state the  number as a tagged value. In Figure 8.1 , I used the tag 
number deployed  to indicate three physical Web servers, but there's no standard tag for this. 
Artifacts are often  the implementati on of a c omponent. T o show this, y ou can use a tagged value in 
the ar tifact box. 
Communicati on paths between nodes indicate  how things communicate. You can label these paths 
with informa tion ab out the c ommunication protocols that are used. 
 
When to Use Deployment Diagrams 
Don't let the brevity of this chapter make y ou think that deployment diagrams sh ouldn't be used. 
They are very handy in showing what is depl oyed where, so any n ontrivial depl oyment can m ake 
good use of them. 
 
Chapter 9. Use Case s 
Use cases are a technique for capturing the fu nctional requirements of a system. Use cases work by 
describing the typical interactions between  the users of a system and the system itself, pr oviding a 
narrative of how a system is used. 
Rather than describe use cases head-on, I find  it easier t o sneak up on them from behind and start 
by describing scenarios. A scenario  is a sequence of steps describing an interacti on between a use r 
and a system. S o if we have a Web-based on-l ine store, we might have a Buy a Product scenari o 
that w ould say  this: 
The cust omer browses the catalog and adds desired  items t o the shopping basket. 
When the customer wishes to pay, the custom er describes the shipping and credi t 
card informati on and c onfirms the sale. The sy stem checks the authorizati on on the 
credit card and confirms the sale both immediately and with a fo llow-up e-ma il. 
This scenari o is one thing  that can happen. However, the credit card authorization might fa il, and 
this would be a separate scenario. In an other case, y ou may have a regular customer for whom you 
don't need to capture  the shipping and credit card information, and  this is a third scenario. 
All these scenari os are different yet similar. The essence of their similarity is that in all  these three 
scenarios,  the user has the same goal: to buy a product. The user doesn't always succeed, but the 
goal remains. This user goal is the key to use cases: A use case  is a set of scenarios  tied toge ther 
by a comm on user goal. 
In use case–speak, the users are referred to as actors. A n actor  is a role that a user plays w ith 
respect to the system. Actors might include cu stomer, customer service rep, sales manager, an d 



80/118 product analyst. Actors carry out use cases. A single actor may perform many use cases; 
conversely, a use case may have several actors performing it. Usually, you have many customers, 
so many people can be the customer actor. Also, one pers on may act as more  than one actor, such 
as a sales manager who does customer service rep tasks. An actor doesn't have to be  human. If th e 
system performs a service for another computer system, that other system is an actor. 
Actor isn't really the right term; role would be  much better. Apparently, there was a mistransla tion 
from Swedish, and actor is the term  the use case c ommunity uses. 
Use cases are well known as an important par t of the UML. However, the surprise is that in many 
ways, the definiti on of use cases in the UML is rather sparse. N othing in the UML describes how you 
should capture the c ontent of a use case.  What the UML describes is a use case diagram, whic h 
shows how use cases relate t o each other. But alm ost all the value of use cases lies in the content, 
and the diagram is of rather limited value. 
 
Content of a Use Case 
There is no standard way to write the c ontent of a use case, and different formats work well in 
different cases. Figure 9 .1 shows a c ommon st yle to use. Y ou begin by pic king one of the scen arios 
as the main success scenar io. You start the body of the use case by writing the main success 
scenario as a sequence of  numbered steps. You then take the other scenari os and wr ite them a s 
extensions , describing them in terms of variat ions on the main success scenario. Extensions can b e 
successes—user achieves the goal, as in 3a—or failures, as in 6a. 
Figure 9.1. Example use case text 
 
Each use case has a primary actor, which ca lls on the system to deliver a service. The primary actor 
is the actor with the goal the use case is trying to satisfy and is usually, but not always,  the initiator 
of the use case. There may be other actors as well with which the system com municates w hile 
carrying out the use case. These are known as secondary actors. 
Each step  in a use case is an element of the interaction between an actor and the system. Eac h step 
should be a simple statement and should clearly show who is carrying out the step. The step shoul d 
show the intent of the actor, n ot the mechanics  of what the actor does. C onseque ntly, you don' t 
describe the user interface in the use case. Indeed, writing  the use case usually precedes designin g 
the user  interface. 



81/118 An extension w ithin the use case names a condi tion that results in different interactions from t hose 
described in the main success scenari o (MSS) and states what those differences are. Start th e 
extensi on by na ming the step at which  the condi tion is detected and provide a short descripti on of 
the condi tion. Follow the condition with numbered steps  in the same style as the main success 
scenario. Finish these steps by describing where you return to the main success scenario, if y ou do. 
The use case structure is a great way to brain storm alterna tives to the main success scenario. For 
each step, ask, How could this go differen tly? and in particular,  What could go wrong?  It's usua lly 
best to brainstorm all the extension condi tions first, before you get bogged down working out the 
consequences. You'll probably think of more c onditions this way, which translates t o fewer g oofs 
that you have to pick up later. 
A complicated step  in a use case can be anoth er use case. In UML terms, we say that  the first  use 
case includes  the sec ond. There's n o standar d way t o show an included use case in the text, but I 
find that under lining, which suggests a hyper link, works very  nicely and  in many t ools really will be 
a hyper link. Thus in Figure 9 .1, the first step includes the use case "browse catalog and select items 
to buy." 
Included use cases can be use ful for a complex step  that would clutter the main scenario or for step s 
that are repeated in several use cases. However, don't try to break down use cases into sub–u se 
cases and subsub–use cases using func tional decomposi tion. Such a decomp osition is a g ood way t o 
waste a lot of time. 
As well as  the steps in  the scenarios, y ou can add some other comm on informati on to a use case. 
• A pre-condition  describes what the system should ensure is true before  the system allows 
the use case to begin. This is useful for telling  the programmers what condi tions they don' t 
have to check for in  their code. 
• A guarant ee describes what the system will ensure at the end of the use case. Success 
guarantees hold after a successful scenario; minimal guarantees hold after any scenario. 
• A trigger  specifies the event that gets  the use case started. 
When you're considering adding elements, be skeptical. It's better to do t oo little than t oo much . 
Also, work hard to keep the use case brief and easy to read. I've f ound that long, detailed use  cases 
don't get read, which rather defeats  the purpose. 
The am ount of detail y ou need in a use case depends on the amount of risk in that use case. O ften, 
you need details on only a few key use cases early on; others can be fleshed out just before y ou 
implement them. You don't have to write all th e detail down; verbal c ommunication is often ve ry 
effective, pa rticularly wit hin an iterative cycle  in which needs are quickly met by run ning code. 
Use Case Diagrams 
As I said earlier,  the UML is silent on the c ontent of a use case but does provide a diagram fo rmat 
for showing them, as in Figure 9.2 . Although the diagram is some times useful, it isn't mandatory. I n 
your use case work, don't put t oo much effort into the diagram. Instead, concentrate on the textua l 
content of  the use cases. 
Figure 9.2. Use case diagram 



82/118 
 
The best way t o think of a use case diagram is that it's a graphical table of c ontents for the use case 
set. It's also sim ilar to the context diagram used in structured methods, as it shows  the syste m 
boundary and the interactions with  the outsid e world. The use case diagram shows the actors, the 
use cases, and the relationships between them : 
• Which actors carry out which use cases 
• Which use cases include other use cases 
The UML includes other rela tionships between  use cases beyond the simple in cludes, such as 
«extend» . I str ongly suggest that you ignore them. I've seen t oo many situati ons in which teams 
can get terribly hung up on when t o use different use case relationships, and such energy is w asted. 
Instead, concentrate on the textual description  of a use case;  that's where the real value of the 
technique lies. 
Levels of Use Cases 
A common problem with use cases is  that by f ocusing on the intera ction between a user and  the 
system, you can neglect s ituations in which a change to a business process may be the best way t o 
deal with the problem. Often, y ou hear people  talk about system use cases and business use cases. 
The terms are n ot precise, but in general, a system use case  is an interac tion with the s oftware, 
whereas a business use case  discusses how a business responds to a customer or an event. 
[Cockburn, use cases] suggests a scheme of levels of use cases. The core use cases are at "sea 
level." Sea-level  use cases typica lly represent a discrete interaction between a primary actor and 
the system. Such use cases will deliver s omething of value t o the primary actor and usually t ake 
from a couple of minutes to half an hour for the primary actor to complete. Use cases that are there 
only because they are  included by sea-level us e cases are fish level . Higher, kite-level  use cases 
show how the sea-level use cases fit into wider business  interacti ons. Kite-level use cases are 
usually bu siness use cases, whereas sea and fish levels are system use cases. Y ou should have mos t 
of your use cases at  the sea level. I prefer t o indicate the level at the top of the use case, as in 
Figure 9.1 . 
 
Use Cases and Features (or Stories) 
Many approaches use features of a system—E xtreme Program ming calls them user stories—t o help 
describe requirements. A common ques tion is how features and use cases interrelate. 



83/118 Features are a g ood way of c hunking up a system for plan ning an iterative pr oject, whereby e ach 
iteration delivers a  number of features. Use cases pr ovide a narrative of how the actors use  the 
system. Hence, although b oth techniques describe requirements, their purposes are different. 
Although y ou can go dire ctly to describing fea tures, many people find it helpful to develop use cases 
first and  then generate a  list of features. A fea ture may be a whole use case, a scenari o in a us e 
case, a step in a use case, or some variant behavior, such as adding yet an other depreciati on 
method for y our asset valua tions, that doesn't show up in a use case narrative. Usually, features 
end up being more fine grained than use cases . 
 
When to Use Use Cases 
Use cases are a valuable t ool to help understand the functional requirements of a system. A fir st 
pass at use cases sh ould be made early on. More detailed versions of use cases sh ould be worked 
just prior to developing that use case. 
It is important t o remember that use cases represent an extern al view of the system. As such, don' t 
expect any correlations between use cases and the classes  inside the system. 
The more I see of use cases,  the less valuable the use case diagram seems to be.  With use cases, 
concentrate y our energy on their text rather  than on the diagram. Despite the fact  that the UML has 
nothing to say ab out the use case text, it is th e text that contains all the value in the technique. 
A big danger of use cases is that people make  them t oo complicated and get stuck. Usually, you'l l 
get less hurt by d oing too little than by d oing too much. A couple of pages per use case is just fine 
for m ost cases. If y ou have t oo little, at least you'll have a short, readable d ocument that's a 
starting point for ques tions. If you have t oo much, hardly anyone will read and understand it. 
 
Where to Find Out More 
Use cases were originally popularized by Ivar Jacobson in [Jacobson, OOSE]. 
Although use cases have been ar ound for a wh ile, there's been little standardizati on on their use. 
The UML is silent on the important contents of a use case and has standardized only the much less 
important diagrams. As a result, you can find a divergent range of op inions on use cases. 
In the last few years, however, [C ockburn, use cases] has bec ome the standard b ook on the 
subject. In  this chapter, I've fo llowed the term inology and advice of that b ook for the excellen t 
reason  that when we've disagreed in  the past, I've usually ended up agreeing w ith Alistair Cockbur n 
in the end. He also maintains a Web site a t http://usecases.org . [Constantine and Lockw ood] 
provides a convincing pr ocess for deriving user interfaces from use cases; also see 
http://foruse.com . 
Chapter 10. State Machine Diagrams 
State machine diagra ms are a fa miliar tec hnique to describe the behavior of a system. Various 
forms of state diagrams have been ar ound since the 1960s and the ear liest object-oriente d 
techniques adopted  them t o show behavior. In object-oriented approaches, you draw a stat e 
machine diagram for a single class to show the lifetime behavior of a single object. 
Whenever people write about state machines, the examples are ine vitably c ruise controls or vendin g 
machines. As I'm a little bored w ith them, I de cided to use a controller for a secret panel in a Gothic 



84/118 castle. In this castle, I want to keep my valuables in a safe that's hard to find. S o to reveal the lock 
to the safe, I have t o remove a strategic candle from its holder, but this will reveal  the lock only 
while the d oor is closed. Once I can see  the lock, I can insert my key to open the safe. For extr a 
safety, I make sure that I can open the safe only if I replace the candle first. If a thief neglects  this 
preca ution, I'll unleash a nasty m onster to devour him. 
Figure 10.1  shows a state machine diagram of the controller class that directs my unusual secur ity 
system.The state diagram starts with the state  of the controller object when it's created:  in Figure 
10.1, the Wait state. The diagram indicates thi s with initial pseudostate , which is not a state bu t 
has an arrow that p oints to the  initial state. 
Figure 10.1. A simple state machine diagram 
 
The diagram shows  that the c ontroller can be i n three states: Wa it, Lock, and Open. The diagram 
also gives the rules by which the c ontroller changes from state to state. These rules are  in the form 
of transiti ons: the lines  that connect the states . 
The transition  indicates a movement from one state to another. Each tran sition has a label tha t 
comes  in three parts : trigger-signature [guard]/activity . All the parts are op tional. Th e 
trigger-signature  is usually a single event that triggers a poten tial change of state. The guard, if 
present, is a B oolean conditi on that must be t rue for the transi tion to be taken. Th e activity  is 
some behavior that's exe cuted during the tran sition. It may be any behavioral expression. The ful l 
form of a trigger-signature  may include mu ltiple events and parameters. So in Figure 10 .1, you 
read the outward transi tion from the Wait state as "In th e Wait state if the candle is remove d 
providing the d oor is open, you reveal the lock and move to the Lock state." 
All three parts to a tran sition are op tional. A m issing activity indicates that you don't do an ything 
during the transition. A missing guard indicates that you always take the transi tion if the even t 
occurs. A missing trigger-signature is rare but does occur. It  indicates that you take  the trans ition 
immediately, which y ou see m ostly with activit y states, which I'll come t o in a moment. 
When an event occurs in a state, you can take only one transi tion out of it. So if you use  multiple 
transi tions with  the same event, as  in the Lock state of Figure 10 .1, the guards must be mutually 
exclusive. If an event occurs and no transiti on is valid—for example, a safe-closed event in  the Wai t 
state or a candle-rem oved event with the d oor closed—the event is ignored. 
The final state indicates  that the state machine  is completed, implying the dele tion of the c ontroller 
object. Thus, if someone should be so careless as t o fall for my trap, the c ontroller objec t 
terminates, s o I would need to put the rabbit in its cage, mop the fl oor, and reb oot the system. 



85/118 Remember that state machines can show only what the object dire ctly observes or activates. S o 
although you might expect me to add or remove things fr om the safe when it's open, I don't pu t 
that on the state diagram, because the c ontroller cann ot tell. 
When developers talk ab out objects, they often refer t o the state of  the objects to mean the 
combinati on of all the data in the fields of the objects. However, the state  in a state machine 
diagram is a more abstract n otion of state; essentially, different states imply a different way of 
reacting to events. 
 
Internal Activities 
States can react to events without transition, using internal activities:  putting the event, gu ard, 
and activity inside  the state box  itself. 
Figure 10.2  shows a state with  internal a ctivities of the character and help events, as you might find 
on a UI text field. An internal activity is similar  to a self-transition:  a transiti on that l oops back t o 
the same state. The syntax for internal activities f ollows the same logic for event, guard, and 
procedure. 
Figure 10.2. Internal events shown with the typing state of a text field 
 
Figure 10.2  also shows two special activi ties: the entry and e xit activities. Th e entry activity  is 
executed whenever y ou enter a state; th e exit activity , whenever you leave. However, internal 
activities d o not trigger the entry and exit a ctivities; that is the difference between internal activi ties 
and self-transiti ons. 
Activity States 
In the states I've described s o far, the object i s quiet and wai ting for the next event before it does 
something. However, y ou can have states in w hich the object is d oing some ong oing work. 
The Searc hing state in Figure 10.3  is such a n activity state:  The ongoing activity is marked with 
the do/; hence  the term do-activity . Once the search is completed, any transi tions with out an 
activity, such as  the one to display new hardware, are taken. If the cancel event occurs during the 
activity,  the do-activity is unceremoniously ha lted, and we go back t o the Update Hardware Window 
state. 
Figure 10.3. A state with an activit y 



86/118 
 
Both do-activities and regular a ctivities represent carrying out some behavior. The cr itical diffe rence 
between the tw o is that regular activities occur "instantane ously" and cannot be interrupted b y 
regular events, wh ile do-ac tivities can take finite time and can be  interrupted, as i n Figure 10.3 . 
Instantane ous will mean different things for different system; for hard real-time systems, it migh t 
be a few ma chine instruc tions, but for desktop software might be several seconds. 
UML 1 used the ter m action for regular activities and used a ctivity only for do-activities. 
 
Superstates 
Often, you'll find that several states share c ommon trans itions and internal activities. In these cases, 
you can make them substates and move the shared behavior into a superstate, as in Figure  10.4. 
Without the superstate, you w ould have to draw a cancel transi tion for all three states wit hin the 
Enter C onnection Details state. 
Figure 10.4. Superstate with nested substates 
 
 
Concurrent States 
States can be broken into several orthogonal state diagrams that run concurrently . Figure 10.5  
shows a pathe tically simple alarm cl ock that can play e ither CDs or the radio and show e ither the 
current time or the alarm time. 



87/118 Figure 10.5. Concurrent orthogonal states 
 
The choices CD/radio and current/alarm time are orthogonal choices. If you wanted t o represent this 
with a nono rthogonal state diagram, you w ould need a messy diagram  that would get very m uch out 
of hand sh ould you want more states. Separa ting out the two areas of behavior  into separate state 
diagrams makes it much clearer. 
Figure 10.5  also includes a history pseudosta te. This indicates that when the clock is switched on, 
the radio/CD choice goes back to the state the  clock was in when it was turned off. The arrow from 
the history pseudostate  indicates what state t o be in on the first time when there is n o history. 
Implementing State Diagrams 
A state diagram can be implemented in three  main ways: nested sw itch, the State pattern, an d 
state tables. The most direct approach t o handling a state diagram is a nested sw itch stateme nt, 
such a s Figure 10.6 . Although it's direct, it's l ong-winded, even for this simple case. It's als o very 
easy for this approach to get out of control, s o I don't  like using it even for simple cases. 
Figure 10.6 A C# nested switch to handle the state transition from Figure 
10.1 
 
public void HandleEvent (PanelEvent anEvent) { 
  switch (CurrentState) { 
    case PanelState.Open : 
      switch (anEvent) { 
        case PanelEvent.SafeClosed : 
          CurrentState = PanelState.Wait; 
          break; 
      } 
      break; 
    case PanelState.Wait : 



88/118       switch (anEvent) { 
        case PanelEvent.CandleRemoved : 
          if (isDoorOpen) { 
            RevealLock(); 
            CurrentState = PanelState.Lock; 
          } 
          break; 
      } 
      break; 
    case PanelState.Lock : 
      switch (anEvent) { 
        case PanelEvent.KeyTurned : 
          if (isCandleIn) { 
            OpenSafe(); 
            CurrentState = PanelState.Open; 
          } else { 
            ReleaseKillerRabbit(); 
            CurrentState = PanelState.Final; 
          } 
          break; 
      } 
      break; 
   } 
  } 
} 
The State pattern  [Gang of Four] creates a  hierarchy of state classes t o handle behavior of th e 
states. Each state in the diagram has one state subclass. The controller has methods for each event, 
which simply forwards to the state class. The state diagram of Figure 10 .1 would yield an 
implementati on indicated by the classes of Figure 10.7 . 
Figure 10.7. A State pattern implementation for Figure 10.1 
 
The top of the hierarchy is an abstract class that implements all the event-handling methods t o do 
nothing. For each c oncrete state, you simply override the specific event methods for which tha t 
state has transitions. 
The state table  approach captures  the state diagram informa tion as data. S o Figure 10.1  might end 
up represented in a table lik e Table 10 .1. We then build either an interpreter that uses the stat e 
table at r untime or a code generator that generates classes based on the state table. 
Obviously, the state table is more work to do once, but  then y ou can use  it every time y ou have a 
state problem t o hold. A runtime state table can also be modified with out recomp ilation, which  in 



89/118 some contexts is quite handy. The state pa ttern is easier to put together when y ou need it, and 
although it needs a new class for each state,  it's a small amount of code to wr ite in each case. 
These implementations are pretty minimal, but  they should give you an idea of how to go abou t 
implementing state diagrams. In each case, implementing state models leads to very bo ilerplat e 
code, so it's usua lly best t o use some form of code generati on to do it. 
Table 10.1. A State Table for Figure 10.1 
Source State Target State Event Guard Procedure 
Wait Lock Candle removed D oor open Reveal l ock 
Lock Open Key turned Candle in Open safe 
Lock Final Key turned Candle out Release killer rabbi t 
Open Wait Safe closed     
When to Use State Diagram s 
State diagrams are g ood at describing the behavior of an object across several use cases.  State 
diagrams are not very g ood at describing behav ior that  involves a number of objects c ollaborat ing. 
As such, it is use ful to combine state diagrams with other tec hniques. For  instance, interaction 
diagrams (see Chapter 4 ) are g ood at describing the behavior of several objects in a single use case, 
and activity diagrams (se e Chapter 11) are g ood at showing  the general sequence of activities for 
several objects and use cases. 
Not everyone finds state diagrams natural. Keep an eye on how people are working with  them. It 
may be that your team does n ot find state diagrams useful to its way of working. That is n ot a big 
problem; as always, y ou should remember t o use the mix of techniques that works for you. 
If you d o use state diagrams, don't try to draw  them for every class in the system.  Although thi s 
approach is often used by high-cerem ony completists, it is alm ost always a waste of effort. Us e state 
diagrams only for th ose classes that exhibit interesting behavior, where bu ilding the state diagram 
helps you understand what is going on. Many people find that UI and c ontrol objects have the kind 
of behavior  that is useful to depict with a state diagram. 
 
Where to Find Out More 
Both the User Guide  [Booch, UML user] and th e Reference Manual  [Rumbaugh, UML Reference ] have 
more informati on on state diagrams. Real-time designers tend t o use state models a lot, s o it's no 
surprise that [Douglass]) has a l ot to say abou t state diagrams, including informa tion on how t o 
implement them. [Martin] c ontains a very g ood chapter on the vari ous ways of implementing state 
diagrams. 
 
Chapter 11. Activity Diagrams 
Activity diagrams are a te chnique to describe procedural logic, bu siness process, and work flow. I n 
many ways, they play a role similar to flowcharts, but the principal difference between them an d 
flowchart notation is that they support para llel behavior. 
Activity diagrams have seen some of the biggest changes over the versi ons of the UML, s o they 
have, n ot surprisingly, been significantly extended and altered again for UML 2. In UML 1, activity 



90/118 diagrams were seen as special cases of state diagrams. This caused a l ot of problems for peopl e 
modeling work flows, which activity diagrams are well suited for. In UML 2, that tie was removed. 
Figure 11.1  shows a simple example of an acti vity diagram. We begin at th e initial node  action and 
then do the action Receive Order. Once  that is done, we encounter a fork. A fork has one  incoming 
flow and several outgoing concurrent flows. 
Figure 11.1. A simple activity diagram 
 
Figure 11.1  says that Fill Order, Send Invoice, and the subsequent ac tions occur in parallel. 
Essen tially, this means that  the sequence between them is irrelevant. I could fill the order, send the 
invoice, deliver, and then receive payment; or,  I could send  the invoice, receive the payment, fill the 
order, and then deliver: Y ou get the pi cture. 
I can also d o these actions by interleaving. I grab the first line item from stores, type up the in voice, 
grab the second line item, put the inv oice in a n envelope, and s o forth. Or, I c ould do some of this 



91/118 simultaneously: type up  the invoice w ith one hand while I reach into my stores with an other. Any of 
these sequences is correct, according t o the diagram. 
The activity diagram allows whoever is d oing the process to ch oose the order in which to d o things. 
In other words, the diagram merely states the  essential sequencing rules I have to f ollow. This is 
important for business modeling because processes often occur  in parallel. It's also useful for 
concurrent algori thms, in which independent t hreads can d o things in para llel. 
When y ou have parallelism, you'll need to syn chronize. We don't close the order until  it is delivered 
and paid for. We show this with the join before the Close Order ac tion. W ith a join, the outgoing 
flow is taken only when all the inc oming flows reach the join. So you can close the order only when 
you have b oth received the payment and delivered. 
UML 1 had particular rules for balan cing the forks and joins, as activity diagrams were special cases 
of state diagrams.  With UML 2, such balancing is n o longer needed. 
You'll n otice that the nodes on an a ctivity diagram are called acti ons, not a ctivities. Stri ctly, an 
activity refers to a sequence of actions, so the diagram shows an activity that's made up of actions. 
Conditional behavior is de lineated by decisions and merges. A decisi on, called branch in UML 1, has 
a single incoming flow and several guarded out-bound flows. Each outbound flow has a guard: a 
Boolean conditi on placed inside square brackets. Each time you reach a decision, you can take only 
one of  the outbound flows, so the guards sh ould be mutually exclusive. Using [else]  as a guar d 
indicates that the [else]  flow sh ould be used if a ll the other guards on the decisi on are false. 
In Figure 11.1 , after an order is filled, there is a decision. If y ou have a rush order, you do an 
Overnight Delivery; otherwise, you do a Regular Delivery. 
A merge has m ultiple input flows and a single output. A merge marks the end of cond itional 
behavior started by a decision. 
In my diagrams, each ac tion has a single flow coming in and a single flow going out. In UML 1, 
multiple incoming flows had an  implic it merge. That is, y our action would execute if any flow 
triggered. In UML 2, this has changed s o there's an implicit join instead; thus,  the action executes 
only if all flows trigger. As a res ult of this change, I rec ommend that you use only a single incoming 
and outgoing flow to an ac tion and show all joins and merges exp licitly; that will avoid confusion. 
Decomposing an Action 
Actions can be decomposed into subactivities. I can take the delivery logic of Figure 11 .1 and define 
it as its own activity ( Figure 11 .2). Then I can  call it as an acti on (Figure 11.3  on page 121). 
Figure 11.2. A subsidiary activity diagram 



92/118 
 
Figure 11.3. The activity of Figure 11.1  modified to invoke the activity in 
Figure 11.2  
 



93/118 Actions can be implemented either as subactivi ties or as methods on classes. You can show a 
subactivity by using the rake symbol. You can show a call on a method with s yntax class-
name::method-name . You can also write a code  fragment  into the action symbol if  the invoked 
behavior isn't a single method call. 
And There's More 
I should stress  that this chapter only scratches  the surface on a ctivity diagrams. As with s o much of 
the UML, you could wr ite a whole b ook on this one te chnique alone. Indeed, I t hink that activity 
diagrams w ould make a very su itable topic for a b ook that really dug into the notation and how t o 
use it. 
The vital ques tion is how widely they get used. Activity diagrams aren't the m ost widely used UML 
technique at the m oment, and their flow-mode ling progenitors weren't very popular either. 
Diagrammatic te chniques haven't yet caught on much for describing behavior  in this kind of way. On 
the other hand, there are signs in a number of communities of a pent-up demand that a standard 
technique will help to satisfy. 
 
When to Use Activity Diagrams 
The great strength of activity diagrams  lies in the fact that they support and encourage paralle l 
behavior. This makes them a great t ool for work flow and process modeling, and indeed much of the 
push in UML 2 has come from people  involved in work flow. 
You can als o use an ac tivity diagram as a UML -compliant flowchart. A lthough this allows you t o do 
flowcharts in a way  that sticks with  the UML, it's hardly very exciting. In principle, you can take 
advantages of the forks and joins to describe parallel algorithms for concurrent programs. Althoug h 
I don't travel in c oncurrent circles  that much, I haven't seen much evidence of people using  them 
there. I think the reason is  that m ost of the complexity of concurrent program ming is in avoidin g 
conten tion on data, and activity diagrams don't help much with that. 
The main strength of doing this may come wit h people using UML as a program ming language.  In 
this case, activity diagrams represent an important technique t o represent behavioral logic. 
I've often seen acti vity diagrams used to describe a use case. The danger of this approach is tha t 
often, domain experts don't f ollow them easily.  If so, you'd be better off with  the usual textual form. 
 
Where to Find Out More 
Although ac tivity diagrams have always been rather c omplicated and are even more so w ith UML 2, 
there hasn't been a g ood book that describes them in depth. I hope this gap will get filled someday. 
Various flow-oriented te chniques are similar in style to ac tivity diagrams. One of the better known—
but hardly well known—is Petri Nets, for which http://www.daimi.au.dk/PetriNets/  is a g ood 
Web site. 
 
Partitions 
Activity diagrams tell you what happens, but they do not tell you who does what. In programm ing, 
this means  that the diagram does n ot convey which class is responsible for each ac tion. In bu siness 



94/118 process mode ling, this does not convey which part of an organizati on carries out which action.  This 
isn't necessarily a problem; often, it makes sense to concentrate on what gets done rather tha n on 
who does what parts of the behavior. 
If you want t o show who does what, y ou can divide an a ctivity diagram  into partitions , which show 
which actions one class or organiza tion unit carries out . Figure 11.4  (on page 122) shows a simple 
example of this, showing how the actions involved in order processing can be separated among 
various departments. 
Figure 11.4. Partitions on an activity diagram 
 
The partiti oning of Figure  11.4 is a simple one-dimensional part itioning. This style is often referred 
to as swim lanes , for obvious reasons and wa s the only form used in UML 1.x. In UML 2, y ou can 
use a two-dimensional grid, so the swimming metaphor n o longer holds water. You can als o take 
each dimension and divide the rows or c olumns hierarchically. 
Signals 
In the simple example of Figure 11 .1, activity diagrams have a clearly defined start p oint, whi ch 
corresponds to an invoca tion of a program or routine. Actions can also respond to signals. 



95/118 A time signal  occurs because of  the passage of time.  Such signals might indicate  the end of a 
month  in a financial period or each microsecond in a real-time controller. 
Figure 11.5  shows an activity that listens for two signals. A signal  indicates that the activity 
receives an event from an outside process. Thi s indicates that the activity constantly listens for 
those signals, and  the diagram de fines how th e activity reacts. 
Figure 11.5. Signals on an activity diagram 
 
In the case of Figure 11.5 , 2 hours before my f light leaves, I need t o start packing my bags. If I'm 
quick to pack them, I still cannot leave un til the taxi arrives. If the taxi arrives before my bags are 
packed, it has to wait for me t o finish before we go. 
As well as accepting signals, we can send them. This is useful when we have to send a message and 
then wait for a reply before we can con tinue. Figure 11 .6 shows a g ood example of this with a 
comm on idiom of timing out. Note that the tw o flows are in a race: The first to reach the final state 
will win and terminate the other flow. 
Figure 11.6. Sending and receiving signals 
 
Although accepts are usua lly just wai ting for a n external event, we can also show a flow g oing into 
them. That indicates  that we don't start listening until the flow triggers the accept. 
Tokens 
If you're sufficiently brave to venture int o the dem onic depths of the UML specification, you'll find 
that the activity sec tion of the specificati on talks a lot ab out tokens and  their producti on and 
consump tion. The  initial node creates a token, which  then passes t o the next ac tion, which exe cutes 
and then passes the token t o the next. At a fork, one token c omes in, and the fork produces a token 



96/118 on each of its outward flows. Conversely, on a join, as each inbound t oken arrives, nothing happen s 
until all the tokens appear at  the join; then a token is produced on the outward flow. 
You can visua lize the t okens w ith coins or cou nters moving across  the diagram. As y ou get to more 
complicated examples of activity diagrams, tokens often make  it easier t o visualize things. 
 
Flows and Edge s 
UML 2 uses the terms flow and edge  synonymously to describe the c onnections between tw o 
actions. The simplest kind of edge is the simpl e arrow between two ac tions. You can give an edge a 
name if you like, but m ost of the time, a simple arrow will suffice. 
If you're ha ving difficulty r outing lines, you can use c onnectors, which simply save y ou having to 
draw a line the whole distance. When y ou use connectors, y ou must use  them in pairs: one w ith 
incoming flow, one with an outgoing flow, and both with  the same label. I tend to avoid usin g 
connectors if at all possible, as they break up  the visualization of the flow of control. 
The simplest edges pass a token that has n o meaning other than to c ontrol the flow. However, you 
can also pass objects along edges; the objects then play the r ole of tokens, as we ll as carry data. If 
you are pas sing an object along the edge, y ou can show that by p utting a class b ox on the edge, or 
you can use pins on  the actions, although pins  imply some more subtle ties that I'll describe shortly. 
All the styles shown in Figure 11.7  are equivalent; you sh ould use whichever conveys best what you 
are trying to communicate. M ost of the time, the simple arrow is quite enough. 
Figure 11.7. Four ways of showing an edge 
 
Pins and Transformations 
Actions can have parameters, just as methods do. You don't need to show informa tion ab out 
parameters on the activity diagram, but if you wish, y ou can show them with pins. If you're 
decomposing an action, pins correspond to the parameter b oxes on the decomp osed diagram. 
When you're drawing an acti vity diagram strictly, you have t o ensure that the output paramete rs of 
an outbound action match the input parameters  of another. If they don't match, you can  indicate a 



97/118 transformati on (Figure 11 .8) to get from one to another. The transforma tion must be an 
expressi on that's free of side effects: essentially, a query on the output pin quary that supplie s an 
object of the right type for the  input pin. 
Figure 11.8. Transformation on a flow 
 
You don't have t o show pins on an activity diagram. Pins are best when you want t o look at th e data 
needed and produced by the various ac tions. I n business process modeling, you can use pins t o 
show the resources produced and c onsumed by ac tions. 
If you use pins,  it's safe to show mu ltiple flows coming into the same ac tion. The pin notati on 
reinforces the implicit join, and UML 1 didn't have pins, so there's no c onfusion with the ear lier 
assumpti ons. 
 
Expansion Regions 
With activity diagrams, you often run into situat ions in which one ac tion's output triggers multiple 
invocations of an other action. There are several ways to show  this, but  the best way is t o use a n 
expansi on region. A n expansion region  marks an activity diagram area where acti ons occur once 
for each item in a co llection. 
In Figure 11.9 , the Ch oose Topics action generates a list of topics as its output. Each element of this 
list then bec omes a token for input to the Write Article action. Similarly, each Review Article ac tion 
generates a single article  that's added t o the output list of  the expansion region.  When all the token s 
in the expansion regi on end up in the output c ollection, the regi on generates a single token for the 
list that's passed to Pub lish Newsletter. 
Figure 11.9. Expansion region 



98/118 
 
In this case, you have  the same  number of  items in the output c ollection as y ou do in  the inpu t 
collection. However, y ou may have fewer, in which case  the expansion regi on acts as a filter. 
In Figure 11.9 , all the articles are written and reviewed in parallel, which is marked by  the 
«concurrent»  keyword. You can also have an iterative expansion region. Iterative regions mus t 
fully process each input element one at a time. 
If you have only a single action  that needs m ultiple invocation, you use the shorthand of Figure 
11.10. The shorthand assumes concurrent expansion, as that's the m ost common. This notati on 
corresponds to the UML 1 concept of dynamic concurrency. 
Figure 11. 10. Shorthand for a single action in an expansion region 
 
 
Flow Final 
Once y ou get multiple tokens, as  in an expansion region, y ou often get flows that stop even when 
the activity as a whole doesn't end. A flow final  indicates the end of one pa rticular flow, with out 
terminating the wh ole activity. 
Figure 11. 11 shows this by modifying the ex ample of Figure 11.9  to allow articles to be rejected. If 
an article is rejected,  the token is destroyed by  the flow final. Unlike an activity final, the rest of th e 
activity can continue. This approach allows expansion regions to act as filters, whereby the outpu t 
collection is smaller  than the  input co llection. 
Figure 11. 11. Flow finals in an activit y 



99/118 
 
Join Specifications 
By defau lt, a join lets execution pass on its outward flow when all its  input flows have arrived a t the 
join. (Or in more formal speak, it em its a token  on its output flow when a token has arrived on each 
input flow.) In some cases, particularly when you have a flow with mu ltiple tokens, it's useful t o 
have a more involved rule. 
A join specification  is a B oolean expressi on attached to a join. Each time a t oken arrives at th e 
join, the join specifica tion is evaluated and if t rue, an output token is emitted. S o in Figure 11. 12, 
whenever I select a drink or insert a c oin, the machine evaluates the join specifica tion. The machine 
slakes my thirst only if I've put in enough money. If, as in this case, you want t o indicate that you 
have received a token on each input flow, y ou label the flows and include  them in the join 
specification. 
Figure 11. 12. Join specification 
 
 



100/118 Chapter 12. Communication Diagrams 
Communication diagra ms, a kind of interac tion diagram, emphasize  the data links between the 
various participants in the interac tion. Instead of drawing each participant as a lifeline and showin g 
the sequence of messages by vertical direc tion as the sequence diagrams does, the com munication 
diagram allows free placement of participants, a llows you to draw links to show how the participant s 
connect, and use numbering t o show the sequence of messages. 
In UML 1.x, these diagrams were called collaboration diagra ms. This name stuck well, and I 
suspect that it will be a while before people ge t used t o the new name. (These are different from 
Collaborati ons [page 143]; hence the name change.) 
Figure 12.1  shows a com munication diagram for the same centralized control interacti on as in Figure 
4.2. With a com munication diagram, we can show how the participants are linked together. 
Figure 12.1. Communication diagram for centralized control 
 
As well as showing links  that are instances of associati ons, we can als o show transient  links, which 
arise only the context of the interaction. In  this case, th e «local»  link fr om Order to Product is a 
local variable; other transient links are «parameter»  and «global» . These keywords were used i n 
UML 1 but are mis sing from UML 2. Because they are useful, I expect them to stay ar ound in 
conventional use. 
The numbering style of Figure 12 .1 is straightforward and commonly used, but a ctually isn't lega l 
UML. To be kosher UML, y ou have to use a nested decimal numbering scheme, as in Figure 12 .2. 
Figure 12.2. Communication diagram with nested decimal numbering 



101/118 
 
The reason for the nested decimal numbers is to res olve ambigu ity with self-calls. I n Figure 4 .2, you 
can clearly see tha t getDiscountInfo  is called within the method calculateDiscount . With the fla t 
numbering of Figure 12 .1, however, you can't te ll whether getDiscountInfo  is called wit hin 
calculateDiscount  or wit hin the overal l calculatePrice  method. The nested numbering scheme 
resolves this problem. 
Despite its illegality, many people prefer a flat numbering scheme. The nested numbers can get very 
tangled, pa rticularly as calls get rather nested, leading t o such sequence  numbers as 1.1.1.2.1.1. In 
these cases,  the cure for ambiguity can be worse than the disease. 
As well as  numbers, you may also see le tters on messages; these letters indicate different  threads 
of control. So messages A5 and B2 w ould be in different  threads; messages 1a1 and 1b1 w ould be 
different  threads c oncurrently nested wit hin message 1. Y ou also see thread letters on sequence 
diagrams, a lthough this doesn't convey the c oncurrency visually. 
Communicati on diagrams don't have any precise nota tion for c ontrol logic. They do a llow you t o use 
iteration markers and guards (page 59), but they don't allow you to fully specify control logic.  There 
is no special nota tion for creating or dele ting objects, but the «create»  and «delete»  keywords are 
comm on conventions. 
When to Use Communication Diagrams 
The main questi on with c ommunicati on diagr ams is when t o use them rather than  the more common 
sequence diagrams. A strong part of the decision is personal preference: Some people  like one  over 
the other. Often,  that drives the choice more  than anything else. On  the whole, most people seem t o 
prefer sequence diagrams, and for once, I'm w ith the ma jority. 
A more ra tional approach says that sequence diagrams are better when you want to emphasize th e 
sequence of calls and  that com munication diagrams are be tter when y ou want to emphasize th e 
links. Many people find that c ommunication diagrams are easier to alter on a wh iteboard, so they 
are a g ood approach for exploring alternatives, although in those cases, I often prefer CRC cards. 
 
Chapter 13. Composite Structures 
One of the m ost significant new features in UML 2 is the ab ility to hierarchically decompose a class 
into an internal structure. This allows you to t ake a complex object and break it down into parts . 
Figure 13.1  shows a TV Viewer class with its provided and required interfaces (page 69). I've shown 
this in two ways: u sing the ball-and-socket nota tion and listing  them internally. 



102/118 Figure 13.1. Two ways of showing a TV viewer and its interfaces 
 
Figure 13.2  shows how this class is decomposed internally into two parts and which parts suppor t 
and require  the different interfaces. Each part is named in the form name : class , with b oth 
elements  individually optional. Parts are not instance specifica tions, s o they are bolded rather  than 
underlined. 
Figure 13.2. Internal view of a component (example suggested by Jim 
Rumbaugh) 
 



103/118 You can show how many instances of a part are present. Figure 13 .2 says that each TV Viewer 
contains one generator part and one controls part. 
To show a part implementing an interface, you draw a delega ting connector fr om that interface . 
Similarly, to show that a part needs an interface, you show a delegating c onnector t o that inte rface. 
You can als o show connectors between parts w ith either a simple line, as I've done here, or wi th 
ball-and-s ocket notati on (page 71). 
You can add ports ( Figure 13 .3) to the external structure. Ports allow you to group the required and 
provided interfaces int o logical interactions that a component has with  the outside world. 
Figure 13.3. A component with multiple ports 
 
 
When to Use Composite Structures 
Compos ite structures are new to UML 2, a lthough s ome older methods had some similar ideas. A 
good way of thinking about the difference between packages and comp osite structures is  that 
packages are a comp ile-time grouping, while composite structures show r untime groupings. A s such, 
they are a natural fit for showing components and how they are broken into parts; hence, mu ch of 
this notation is used in comp onent diagrams. 
Because composite structures are new t o the UML, it's too early t o tell how effe ctive they will tur n 
out in pra ctice; many members of the UML c ommittee think that these diagrams will become a very 
valuable addi tion. 
 
Chapter 14. Component Diagrams 
A debate that's always ranged large in  the OO community is what  the difference is between a 
component and any regular class. This is n ot a debate  that I want t o settle here, but I can show you 
the notati on the UML uses to distinguish betw een them. 
UML 1 had a distinctive symb ol for a comp onent (Figure 14.1 ). UML 2 removed that ic on but allows 
you to annotate a class box w ith a similar-l ooking icon. Alternatively, you can use th e «component»  
keyword. 
Figure 14.1. Notation for components 



104/118 
 
Other than  the icon, comp onents don't introdu ce any notation  that we haven't already seen. 
Components are c onnected through implemented and required interfaces, often using the ball-and-
socket notati on (page 71) just as for class diagrams. You can also decompose comp onents by  using 
composite structure diagrams. 
Figure 14.2  shows an example component dia gram. In this example, a sales till can c onnect to a 
sales server comp onent, using a sales message interface. Because the network is  unreliable, a 
message queue component is set up so the t ill can talk t o the server when the network is up and 
talk to a queue when the network is down; the queue will then talk to the server when the network 
becomes available. As a result, the message queue both supplies the sales message interface to talk 
with the till and requires that  interface t o talk with the server. The server is broken down into tw o 
major components. The transacti on processor rea lizes the sales message  interface, and the 
accounting driver talks t o the acc ounting system. 
Figure 14.2. An example component diagram 
 
As I've already said, the issue of what is a component is  the subject of endless debate. One of  the 
more helpful statements I've f ound is this: 
Components are n ot a technology. Technology people seem t o find this hard t o 
understand. Components are ab out how customers want to relate to s oftware. They 
want to be able t o buy their software a piece at a time, and to be able t o upgrade i t 
just like they can upgrade their stereo. They want new pieces to work seamlessly wit h 
their old pieces, and to be able t o upgrade on  their own schedule, not the 
manufa cturer's schedule. They want to be able  to mix and match pieces from various 
manufa cturers. This is a very reasonable requirement. It is just hard to satis fy. 
Ralph J ohnson, http://www.c2.com/cgi/wiki?DoComponentsExist  
The important p oint is that components represent pieces  that are  independently purchasable and 
upgradeable. As a re sult, dividing a system  into components is as much a marke ting decisi on as it i s 
a technical decision, for which [H ohmann] is an exce llent guide. It's also a reminder to beware of 



105/118 overly fine-grained comp onents, because t oo many components are hard to manage, especiall y 
when versioning rears its ugly head, hence "DLL he ll." 
In earlier versions of the UML, components were used to represent physical structures, such a s 
DLLs. That's no longer true; for this task, you  now use artifacts (page 97). 
When to Use Component Diagrams 
Use component diagrams when y ou are dividing your system into components and want to sho w 
their interrelation ships through interfaces or the breakdown of components into a lower-leve l 
structure. 
 
Chapter 15. Collaborations 
Unlike the other chapters in this book, this on e does not correspond to an official diagram in UML 2. 
The standard discusses c ollabora tions as part of composite structures, but the diagram is really 
quite different and was used in UML 1 w ithout any link t o comp osite structures. S o I felt it best t o 
discuss c ollaborati ons as their own chapter. 
Let's consider  the notion of an auction. In any auc tion, we might have a se ller, some buyers, a  lot of 
goods, and some offers for the sale. We can describe these elements  in terms of a class diagr am 
(Figure 15 .1) and perhaps some interaction diagrams ( Figure  15.2). 
Figure 15.1. A collaboration with its class diagram of roles 
 
Figure 15.2. A sequence diagram for the auction collaboration 



106/118 
 
Figure 15.1  is not qu ite a regular class diagram. For a start, it's surr ounded by the dashed el lipse, 
which represents the auc tion co llabora tion. Second, the so-ca lled classes in the co llaboration a re not 
classes bu t roles  that will be realized as the c ollabora tion is app lied—hence the fact  that their 
names aren't cap italized. It's n ot unusual to s ee actual interfaces or classes that correspond t o the 
collabora tion roles, but y ou don't have t o have them. 
In the interacti on diagram, the participants are labeled slig htly differently fr om the usual case. In a 
collabora tion, the naming scheme is participant-name /role-name : class-name . As usual, al l 
these elements are op tional. 
When y ou use a c ollaboration, you can show that by placing a c ollaboration occurrence on a cl ass 
diagram, as i n Figure 15.3 , a class diagram of some of the classes in the applica tion. The links from 
the collaborati on to those classes  indicate how  the classes play the various roles defined  in the 
collabora tion. 
Figure 15.3. A collaboration occurrence 



107/118 
 
The UML suggests that you can use the c ollabora tion occurrence notati on to show the use of 
patterns, but hardly any patterns a uthor has done this. Erich Gamma developed a nice alternative 
notati on (Figure 15.4 ). Elements of the diagram are labeled w ith either the pattern name or a 
combinati on of pattern:role . 
Figure 15.4. A nonstandard way of showing pattern use in JUnit (junit.org) 
 
When to Use Collaboration s 
Collaborati ons have been ar ound since UML 1, but I admit I've hardly used them, even in m y 
patterns writing. Co llabora tions do provide a way to group c hunks of intera ction behavior when roles 
are played by different classes. In practice, however, I've n ot found that they've been a compellin g 
diagram type. 
Chapter 16. Interaction Overview Diagram s 
Intera ction overview diagrams are a grafting together of activity diagrams and sequence diagrams. 
You can  think of interaction overview diagrams either as activity diagrams in which the ac tivities are 



108/118 replaced by little sequence diagrams, or as a sequence diagram br oken up with acti vity diagr am 
notati on used to show c ontrol flow. Either way,  they make a bit of an odd mixture. 
Figure 16.1  shows a simple example of one;  the nota tion is familiar fr om what you've already seen 
in the activity diagram and sequence diagram chapters. In this diagram, we want to produce and 
format an order summary report. If the customer is external, we get  the informa tion from XML; if 
internal, we get it fr om a database. Small sequence diagrams show  the two alternatives. Once we 
get the data, we format the report; in this case, we don't show the sequence diagram but simply 
reference it with a reference interac tion frame. 
Figure 16.1. Interaction summary diagram 
 
 
When to Use Interaction Overview Diagrams 
These are new for UML 2, and it's t oo early to get much sense of how well they will work out in 
practice. I'm n ot keen on them, as I think that  they mix two styles  that don't really mix that well. 
Either draw an ac tivity diagram or use a sequence diagram, depending on what better serves your 
purpose. 



109/118  
Chapter 17. Timing Diagrams 
After leaving secondary sch ool, I started out in electr onic engineering before I sw itched int o 
computing. So I feel a certain anguished fami liarity when I see the UML define timing diagrams as 
one of its standard diagrams. Ti ming diagrams  have been around in electronic engineering for a  long 
time and never seemed t o need the UML's help  to define  their meaning. But since they are in  the 
UML, they deserve a brief mention. 
Timing diagrams are another form of interac tion diagram, where  the focus is on timing constra ints: 
either for a single object or, more usef ully, for a bunch of objects. Let's take a simple scenario based 
on the pump and hotplate for a coffee pot. Let' s imagine a rule that says that at least 10 seconds 
must pass between  the pump c oming on and the hotplate coming on. When  the water reservoi r 
becomes empty,  the pump switches off, and  the hotplate cannot stay on for more than 15 mi nutes 
more. 
Figures 17 .1 and 17.2 are alternative ways of showing these  timing c onstraints. B oth diagrams  show 
the same basic information. The main difference is tha t Figure 17.1  shows the state changes b y 
moving from one horizontal line to an other, wh ile Figure 17.2  retains the same horizontal p osition 
but shows state changes with a cross. The style  of Figure  17.1 works better when there are just a 
few states, as in this case, an d Figure 17.2  is be tter when there are many states to deal with. 
Figure 17.1. Timing diagram showing states as lines 
 
Figure 17.2. Timing diagram showing states as areas 



110/118 
 
The dashed lines that I've used on the {>10s} constraints are optional. Use them if y ou think they 
help clarify exactly what events the timing con strains. 
 
When to Use Timing Diagrams 
Timing diagrams are useful for showing timing constraints between state changes on differen t 
objects. The diagrams are pa rticularly familiar to hardware engineers. 
Appendix Changes between UML Versions 
When the first edition of this book appeared on  the shelves, the UML was in versi on 1.0. Much of i t 
appeared to have stabilized and was in the pr ocess of OMG recogn ition. Since then, there hav e been 
a number of revisions. In this appendix, I describe the significant changes that have occurred since 
1.0 and how those changes affect the material in this b ook. 
This appendix summarizes the changes so y ou can keep up to date if you have an ear lier pri nting of 
the book. I have made changes t o the book to keep up with the UML, s o if you have a later printing, 
it describes the situati on as it was as of  the print date. 
 
Revisions to the UML 
The earliest public release of what came to be  the UML was versi on 0.8 of the Unified Method, which 
was released for OOPSLA in October 1995. This was the work of B ooch and Rumbaugh, as Jacobson 
did not join Rational until around that time. In  1996, Rational released versions 0.9 and 0.91, which 
included Jacobson's work. After the latter version, they changed the name t o the UML. 
Rational and a group of pa rtners submitted vers ion 1.0 of  the UML t o the OMG Analysis and De sign 
Task Force in January 1997. Subsequently, th e Rational partnership and the other submitters 
combined  their work and subm itted a single proposal for the OMG standard in September 1997, for 
version 1.1 of the UML. This was adopted by the OMG toward  the end of 1997. However,  in a fit  of 
darkest obfusca tion, the OMG called this standard versi on 1.0. So, now the UML was b oth OMG 



111/118 version 1.0 and Rational version 1.1, n ot to be confused with Ra tional 1.0. In practice, everyon e 
calls that standard versi on 1.1. 
From then on, there were a number of fu rther developments in the UML. UML 1.2 appeared in 1998, 
1.3 in 1999, 1.4 in 2001, and 1.5  in 2002. M ost of the changes between the 1.x versi ons were fairly 
deep in  the UML, except for UML 1.3, which caused s ome very visible changes, especially to us e 
cases and activity diagrams. 
As the UML 1 series c ontinued, the developers of the UML set  their sights on a ma jor revision t o the 
UML with UML 2. The first RFPs (Request for Proposals) were issued in 2000, but UML 2 didn't star t 
to properly stabilize un til 2003. 
Further developments in the UML will alm ost certainly occur. The UML Forum ( http://uml-
forum.com ) is usually a g ood place t o look for more information. I als o keep some UML informa tion 
on my site ( http://martinfowler.com ). 
 
Changes in UML Distilled  
As these revisions go on, I've been trying t o keep up by revising UML Disti lled with subsequen t 
printings. I've also taken the opportunity to fix  errors and make clarifica tions. 
The m ost dynamic period for keeping up with things was during  the first edi tion of UML Distilled , 
when we often had to make updates between printings t o keep up with the emerging UML standard. 
The first through fifth pr intings were based on UML 1.0. Any changes t o the UML between  these 
printings were minor. The si xth printing took UML 1.1  into acc ount. 
The seventh through tenth pr intings were based on UML 1.2; the eleventh prin ting was the firs t to 
use UML 1.3. Pri ntings based on versi ons of the UML after 1.0 have the UML versi on number on th e 
front cover. 
The first though sixth prin tings of the second edi tion were based on versi on 1.3. The seventh 
printing was the first t o take into acc ount the minor changes of version 1.4. 
The third editi on was launched t o update the b ook with UML 2 (see Table A.1 ). In the rest of this 
appendix, I summarize the ma jor changes in  the UML from 1.0 to 1.1, from 1.2 t o 1.3, and from 1.x 
to 2.0. I don't discuss all the changes that occur but rather only those that change something I said 
in UML Distilled  or that represent important features that I would have discussed  in UML Di stilled. 
I am c ontinuing to fo llow the spirit of UML Di stilled: to discuss the key elements of UML as they 
affect the applica tion of the UML w ithin real-world pr ojects. As ever, the selec tions and advice are 
my own. If there is any c onflict between what I say and the official UML d ocuments, the UML 
documents are the ones to f ollow. (But do let  me know, so I can make correc tions.) 
Table A.1. UML Distilled and corresponding UML versions  
UML Distilled  UML Versions 
1st edition  UML 1.0–1 .3 
2nd edition  UML 1.3–1 .4 
3rd edition  UML 2.0 onward  
I have als o taken  the oppor tunity to indicate any important errors and omissions in the earlie r 
printings. Thanks t o the readers wh o have poi nted these out to me. 
 



112/118 Changes from UML 1.0 to 1.1 
Type and  Implementation Class 
In the first ed ition of UML Distilled , I talked about perspectives and how they altered the way people 
draw and interpret models—in particular, class diagrams. UML now takes this into acc ount by saying 
that all classes on a class diagram can be specia lized as either types or implementa tion classes . 
An implementation class  corresponds to a class in the software envir onment in which you ar e 
developing. A type is rather more nebulous;  it represents a less implementation-bound abstra ction. 
This could be a CORBA type, a specification perspective of a class, or a c onceptual perspective. If 
necessary, y ou can add stereotypes to differen tiate fu rther. 
You can state  that for a particular diagram, all classes f ollow a particular stereotype. This is wha t 
you w ould do when drawing a diagram from a particular perspective. The implementati on 
perspective would use implementati on classes, whereas the specifica tion and conceptual perspective 
would use types. 
You use the realizati on relati onship to indicate  that an implementa tion class implements one or more 
types. 
There is a di stinction between type and interface. An interface is  intended to directly correspond to a 
Java or COM-style  interface. Interfaces thus h ave only opera tions and no attributes. 
You may use only single, static classificati on with implementati on classes, but you can use mul tiple 
and dynamic classificati on with types. (I assume that  this is because the ma jor OO languages f ollow 
single, static classification. If one fine day you  use a language that supports multiple or dynam ic 
classifica tion, that restri ction really should not apply.) 
Complete and  Incomplete Discriminator Constraints 
In previous printings of UML Distilled , I said  that the {complete}  constraint on a generalizati on 
indicated that all instances of the supertype must also be an instance of a subtype within tha t 
partition. UML 1.1 de fines instead tha t {complete}  indicates that a ll subtypes wi thin that par tition 
have been specified, which is n ot quite the sa me thing. I have f ound some inconsistency on the 
interpreta tion of this constraint, so you sh ould be wary of it. If you do want to indicate that al l 
instances of the supertype sh ould be an insta nce of one of the subtypes, I suggest using an other 
constra int to avoid c onfusion. Curre ntly, I am using {mandatory} . 
Composition 
In UML 1.0, using comp osition implied  that the link was im mutable, or frozen, at least for single-
valued components. That c onstraint is no l onger part of the de finition. 
Immutab ility and Frozen 
UML defines the constrain t {frozen}  to de fine immutability on ass ociation roles. As it's currently 
defined, it doesn't seem to apply it to a ttributes  or classes.  In my practice, I now use  the term 
frozen  instead of immutability, and I'm happy  to apply  the constra int to ass ociation roles, classes, 
and a ttributes. 
Returns  on Sequence Diagrams 
In UML 1.0, a return on a sequence diagram was distinguished by using a s tick arrowhead  instead of 
a solid arrowhead (see previous pr intings). Thi s was somet hing of a pain, as the distinction was t oo 
subtle and easy t o miss. UML 1.1 uses a dashed arrow for a return, which pleases me, as it m akes 
returns much more obvious. (As I used dashed returns in Analysis Pa tterns [Fowler, AP],  it also 



113/118 makes me l ook influen tial.) You can name what is returned for later use by using the form 
enoughStock := check() . 
Use of the  Term "Role " 
In UML 1.0, the ter m role indicated primarily a direc tion on an ass ociation (see previous prin tings). 
UML 1.1 refers t o this usage as a n association role . There is also a collaboration role , which is a 
role that an instance of a class plays in a c ollabora tion. UML 1.1 gives a lot more emphasis t o 
collabora tions, and it l ooks as though this use of "role" may become the primary one. 
 
Changes from UML 1.2 (an d 1.1) to 1.3 (and 1.5) 
Use Cases 
The changes to use cases  involve new rela tionships between use cases. UML 1.1 has two use c ase 
relationships: «uses»  and «extends» , both of which are stereotypes of generaliza tion. UML 1. 3 
offers  three relation ships. 
• The «include»  construct is a stereotype of de pendency. This indicates that the path of on e 
use case is included in another. Typically, this occurs when a few use cases share common 
steps. The included use case can factor out the comm on behavior. An example from an ATM 
might be that  Withdraw Money and Make Transfer b oth use Va lidate Customer. This replaces 
the common use of «uses» . 
• Use case generalization  indicates that one use case is a varia tion on another. Thus, we 
might have one use case for  Withdraw Money—the base use case—and a separate use case 
to handle the case when the withdrawal is refused because of lack of funds. The refusal coul d 
be handled as a use case that specia lizes the w ithdrawal use case. (You could also handle i t 
as simply an other scenario w ithin th e Withdraw Money use case.) A specializing use case like 
this may change any aspect of the base use case. 
• The «extend»  construct is a stereotype of dependency. This pr ovides a more contro lled form 
of extension than the genera lization rela tionship. Here, the base use case declares a  number 
of extension p oints. The extending use case can alter behavior only at those extension 
points. So, if y ou are buying a product on line,  you might have a use case for bu ying a 
product w ith extension points for capturing the  shipping informati on and capturing paymen t 
informa tion. That use case could then be extended for a regular customer for which this 
informa tion would be obtained in a different way. 
There is some confusion about the relationship between the old relationships and the new ones. 
Most people used «uses»  the way the 1.3 «includes»  is used, s o for m ost people, we can say  that 
«includes»  replaces «uses» . And most peopl e used 1. 1 «extends»  in both the c ontrolled manner of 
the 1.3 «extends»  and as a general overriding  in the style of the 1.3 generaliza tion. So, you can 
think that 1.1 «extends»  has been sp lit into the 1.3 «extend»  and generaliza tion. 
Now, a lthough this explana tion covers most UML usage that I've seen,  it isn't the stric tly corr ect way 
of using those old relationships. However, mos t people didn't fo llow the strict usage, and I don' t 
really want to get  into all that here. 
Activity Diagrams 
When the UML reached version 1.2, there were quite a few open questions ab out the sema ntics of 
activity diagrams. So, the 1.3 effort inv olved q uite a lot of tightening up on these sema ntics. 
For conditional behavior, you can now use  the diamond-shaped decision a ctivity for a merge of 
behavior as well as a branch. A lthough ne ither branches nor merges are necessary t o describ e 
conditional behavior, it is increa singly c ommon style to show them s o that you can bracke t 
conditional behavior. 



114/118 The synchr onization bar is now referred to as a fork—when splitting c ontrol—or as a join—when 
synchronizing control together. However, you can no longer add arb itrary conditions to joins. Also, 
you must f ollow matching rules to ensure that forks and joins match up. Esse ntially, this means tha t 
each fork  must have a corresponding join that joins the  threads started by that fork. Y ou can nest 
fork and joins, though, and y ou can eliminate forks and joins on the diagram when  threads g o 
directly from one fork to another fork, or one join to another join. 
Joins are fired only when all incoming threads  complete. However, you can have a conditi on on a 
thread c oming out of a fork. If that condition is false, that  thread is c onsidered complete for joining 
purposes. 
The mul tiple-trigger feature is no longer prese nt. In its place, y ou can have dynamic concurrency in 
an activity, shown w ith a * inside an activity box. Such an activity may be  invoked several times in 
parallel; all its invocations must complete before any outgoing transi tion can be taken. This is 
loosely equivalent to, although less flexible  than, a mul tiple trigger and matching synchr onization 
condition. 
These rules reduce some of flexibility of a ctivity diagrams but do ensure that activity diagrams are 
truly special cases of state machines. The relationship between acti vity diagrams and state ma chines 
was a matter of some debate in the RTF. Futur e versions of the UML (after 1.4) may well mak e 
activity diagrams a completely different form of diagram. 
Changes from UML 1.3 to 1.4 
The m ost visible change in UML 1.4 is the addit ion of profiles , which allows a group of extensions t o 
be collected together into a coherent set. The UML documentation  includes a couple of exampl e 
profiles. Together with  this, there's greater fo rmalism involved in defi ning a stereotype, and mode l 
elements can now have multiple stereotypes; they were limited to one stere otype in UML 1.3. 
Artifacts  were added to the UML. An a rtifact is a physical manifestation of a component, so, fo r 
example, Xerces is a comp onent and all those  copies of the Xerces jar on my disk drive are artifact s 
that implement the Xerces component. 
Prior to 1.3, there was n othing in the UML meta-model t o handle Java's package visibility . Now 
there is, and the symb ol is "~". 
UML 1.4 also made the stick arrowhead in interaction diagrams mark asynchronous, a rathe r 
awkward backward-incompatible change. That caught out a few people, including me. 
 
Changes from UML 1.4. to 1.5 
The principal change here was adding ac tion semantics to the UML, a necessary step t o make UML a 
programming language. This was done to a llow people to work on this with out waiting for the fu ll 
UML 2. 
 
From UML 1.x to UML 2.0 
UML 2 represents the biggest change that's happened yet to the UML. All sorts of things have 
changed with this revision, and many changes have affected UML Distilled . 
Within the UML,  there have been deep change s to the UML meta-model.  Although these changes 
don't affect the discussi on in UML Dis tilled, they are very important to s ome groups. 



115/118 One of the m ost obvious changes is  the introd uction of new diagram types. Object diagrams an d 
package diagrams were widely drawn before but weren't official diagram types; now they are. UML 2 
changed the name of co llabora tion diagrams to communica tion diagrams. UML 2 has als o introduce d 
new diagram types: interac tion overview diagrams, timing diagrams, and composite stru cture 
diagrams. 
A lot of changes haven't t ouched UML Di stilled. I've left out discussi on of such constructs as state 
machine extensi ons, gates in interactions diagrams, and power types in class diagrams. 
So for this se ction, I'm discussing only changes that make  it into UML Di stilled. These are eithe r 
changes t o things I discussed in previ ous editi ons or new things I've started to discuss w ith this 
edition. Because the changes are so widespread, I've organized them according t o the chapter s in 
this b ook. 
Class Diagrams:  The Essentials  (Chapter  3) 
Attributes and unidirectional associa tions are now primarily simply different notations for  the same 
underlying concept of property. Discon tinuous  multiplicities, such as [2, 4], have been dropped. Th e 
frozen property has been dropped. I've added a list of common dependency keywords, several of 
which are new to UML 2. Th e «parameter» , and «local»  keywords have been dropped. 
Sequence Diagrams  (Chapter  4) 
The big change here is  the interacti on frame n otation for sequence diagrams t o handle iterative, 
conditional, and various other controls of beha vior. This now allows you to express algorithms pretty 
completely  in sequence diagrams, although I' m not convinced  that these are any clearer than code. 
The old iterati on markers and guards on messages have been dropped fr om sequence diagrams. The 
heads of the lifelines are n o longer instances; I use the term participant  to refer t o them. Th e 
collabora tion diagrams of UML 1 were renamed to communica tion diagrams for UML 2. 
Class Diagrams: Concepts  (Chapter  5) 
Stereotypes are now more tig htly defined. As a resu lt, I now refer to words in guillemets as 
keywords, only s ome of which are stere otypes.  Instances on object diagrams are now instanc e 
specifications. Classes can now require interfaces as well as provide them. Mul tiple classification 
uses genera lization sets t o group generaliza tions into groups. Components are no longer draw n with 
their special symbol. Active objects have double vertical  lines instead of thick lines. 
State Machine Diagrams  (Chapter 10 ) 
UML 1 separated short-lived ac tions from long- lived activities. UML 2 calls b oth activities and uses 
the term do-activity for the long-lived activities. 
Activity Diagrams  (Chapter 11 ) 
UML 1 treated activity diagrams as a special case of state diagram. UML 2 broke that link and as a 
result removed  the rules of matching forks and joins that UML 2 a ctivity diagrams had t o keep to. As 
a result, they are best  underst ood by token flow rather than by state transition. A whole bunch  of 
new nota tion thus appeared, including time an d accept signals, parameters, join specifica tions, pins, 
flow transformations, subdiagram rakes, expa nsion regions, and flow finals. 
A simple but awkward change is that UML 1 treated multiple incoming flows to an activity as an 
implicit merge, while UML 2 treats them as an  implic it join. For this reason, I advise using an  explicit 
merge or join when doing activity diagrams. 
Swim lanes can now be m ultidimensional and are generally called par titions. 
 



116/118 Bibliograph y 
[Amble r] Scott Ambler, Agile Modeling , Wiley, 2002. 
[Beck] Kent Beck , Extreme Programming Explained: Embrace Chan ge, Addison-Wesley, 2000. 
[Beck and Fowle r] Kent Beck and Martin Fowler, Planning Extreme Programming , Addison-Wesley , 
2000. 
[Beck and Cunningha m] Kent Beck an d Ward Cunningham, "A Laboratory for Teaching Obje ct-
Oriented Thinking," Proceedings of OOPSLA 89 , 24 (10): 1–6. 
http://c2.com/doc/oopsla89/paper.ht ml 
[Booch, OOA D] Grady B ooch, Object-Oriente d Analysis and Design w ith Applica tions, Secon d 
Edition. Addison-Wesley, 1 994. 
[Booch, UML user]  Grady B ooch, Jim Rumbaugh, and Ivar Jacobson, UML User  Guide, Addis on-
Wesley, 1999. 
[Coad, OO A] Peter Coad and Edward Yourdon, Object-Oriented Analys is, Yourdon Press, 1991 . 
[Coad, OOD]  Peter Coad and Edward Yourdon, Object-Oriented Desi gn, Yourd on Press, 1991. 
[Cockburn, agile]  Alistair Cockburn, Agile Software Developme nt, Addison-Wesley, 2001. 
[Cockburn, use cases]  Alistair C ockburn, Writing Effec tive Use Cases , Addison-Wesley, 2001. 
[Constantine and Lockwoo d] Larry C onstantine and Lucy Lockw ood, Software for Use , Addison-
Wesley, 2000. 
[Cook and Daniels]  Steve C ook and J ohn Daniels, Designing Object Systems: Object-Oriented 
Modeling with Syntro py, Prentice-Ha ll, 1994. 
[Core J2EE Patterns]  Deepak Alur, J ohn Crupi, and Dan Malks, Core J 2EE Patterns , Prentice-Ha ll, 
2001. 
[Cunningha m] Ward Cun ningham, "EPISOD ES: A Pattern Language of Competitive Development." 
In Pattern Languages of Program Design 2 , Vlissides, Cop lien, and Kerth, Addison-Wesley, 1996, pp. 
371–388. 
[Douglass]  Bruce Powel Douglass, Real-Time UML , Addison-Wesley, 1999. 
[Fowler, AP]  Martin Fowler, Analysis Patterns: Reusable Object Mode ls, Addison-Wesley, 1997 . 
[Fowler, new methodology]  Martin Fowler, "The New Methodology," 
http://martinfowler.com/articles/newMethodology.ht ml 
[Fowler and Foe mmel] Martin Fowler and Matthew Foemmel, "Continu ous Integra tion," 
http://martinfowler.com/articles/continuousIntegration.ht ml 
[Fowler, P of EAA] Martin Fowler, Patterns of Enterprise Applica tion Architecture , Addison-Wesley , 
2003. 
[Fowler, refactorin g] Martin Fowler, Refactoring: Impr oving the Design of Existing Progra ms, 
Addison-Wesley,  1999. 



117/118 [Gang of Fou r] Erich Gamma, Richard Helm, Ralph J ohnson, and J ohn Vlissides, Design Patterns: 
Elements of Reusable Object-Oriented S oftware , Addison-Wesley, 1995. 
[Highsmith]  Jim Highsmith , Agile Software Development Ecosystems , Addison-Wesley, 2002. 
[Hohmann]  Luke Hohmann, Beyond S oftware Archite cture, Addison-Wesley, 2003. 
[Jacobson, OOSE]  Ivar Jacobson, Magnus Christerson, Patrik J onsson, and Gunnar Övergaard , 
Object-Oriented Software Engineering: A Use Case Driven Approa ch, Addison-Wesley, 1 992. 
[Jacobson, UP]  Ivar Jacobson, Maria Ericsson, and Agneta Jacobson, The Object Advantage: 
Business Process Reengineering with Object T echnology , Addison-Wesley, 1 995. 
[Kert h] Norm Kerth, Project Retrospec tives, Dorset House, 2001 
[Kleppe et al.]  Anneke Kleppe, J os Warmer, and Wim Bast, MDA Explained , Addison-Wesley, 2003. 
[Kruchte n] Philippe Kruchten, The Ra tional U nified Process: An Introduc tion, Addis on-Wesley, 
1999. 
[Larman]  Craig Larman, Applying UML and Pa tterns, 2d ed., Prentice-Ha ll, 2001. 
[Marti n] Robert Cecil Martin, The Principles, Pa tterns, and Practices of Agile Software Developme nt, 
Prentice-Ha ll, 2003. 
[McConnell]  Steve McC onnell, Rapid Development: Taming  Wild Software Schedul es, Micros oft 
Press, 1996. 
[Mellor and Balcer]  Steve Mellor and Marc Balcer, Executable UML , Addison-Wesley, 2002. 
[Meyer]  Bertrand Meyer, Object-Oriented Software Construc tion. Prentice-Ha ll, 2000. 
[Odell]  James Mar tin and James J. Ode ll, Object-Oriented Methods: A Foundation (UML Edi tion), 
Prentice Hall, 1998. 
[Pont]  Michael P ont, Patterns for Time-Trigge red Embedded Systems , Addison-Wesley, 2001. 
[POSA1]  Frank Buschmann, Regine Meunier,  Hans Rohnert, Peter Sommerlad, and Michael Stal, 
Pattern-Oriented Software Archite cture: A System of Pa tterns, Wiley, 1 996. 
[POSA2]  Douglas Schmidt, Michael Stal, Han s Rohnert, and Frank Bus chmann, Pattern-Oriented 
Software Archtecture V olume 2: Patterns for Concurrent and Networked Objec ts, Wiley,  2000. 
[Rumbaugh, insights]  James Rumbaugh , OMT Insigh ts, SIGS B ooks, 1996. 
[Rumbaugh, OMT]  James Rumbaugh, Michael Blaha, William Premerlani, Frederick Eddy, an d 
William Lorenzen , Object-Oriented Modeling and Design , Prentice-Hall, 1991. 
[Rumbaugh, UML Referenc e] James Rumbaugh, Ivar Jacobson, and Grady B ooch, The Unified 
Modeling Language Reference Manual , Addison-Wesley, 1999. 
[Shlaer and Mellor, data]  Sally Shlaer and Stephen J. Mellor, Object-Oriented Systems Analysis : 
Modeling th e World  in Data, Yourd on Press, 1989. 
[Shlaer and Mellor, state s] Sally  Shlaer and Stephen J. Mellor, Object Lifecycles: Modeling the 
World in States . Yourdon Press, 1991. 



118/118 [Warmer and Kleppe]  Jos Warmer and Anneke Kleppe, The Object Constraint Language: Precise 
Modeling with UML , Addison-Wesley, 1998. 
[Wirfs-Brock]  Rebecca Wirfs-Brock and Alan McKean, Object Design: R oles Responsibilities an d 
Collaborati ons. Prentice-Ha ll, 2003. 



